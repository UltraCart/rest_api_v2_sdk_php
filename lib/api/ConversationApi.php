<?php
/**
 * ConversationApi
 * PHP version 5
 *
 * @category Class
 * @package  ultracart\v2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * UltraCart Rest API V2
 *
 * UltraCart REST API Version 2
 *
 * OpenAPI spec version: 2.0.0
 * Contact: support@ultracart.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.15-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace ultracart\v2\api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use ultracart\v2\ApiException;
use ultracart\v2\Configuration;
use ultracart\v2\HeaderSelector;
use ultracart\v2\ObjectSerializer;

/**
 * ConversationApi Class Doc Comment
 *
 * @category Class
 * @package  ultracart\v2
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ConversationApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }


    /**
     * @param string $simple_key api key
     * @param int $max_retry_seconds 0 to disable, else the maximum number of seconds to wait and automatically retry when rate limit is hit
     * @param string $verify passed to Guzzle to enable/disable ssl verify
     */
    public static function usingApiKey( $simple_key, $max_retry_seconds = 0, $verify = true) {
        $config = new Configuration();
        $config->setApiKey('x-ultracart-simple-key', $simple_key);
        $config->setMaxRetrySeconds($max_retry_seconds);

        $client = new Client(['verify' => $verify, 'debug' => false]);
        $headerSelector = new HeaderSelector(/* leave null for version tied to this sdk version */);
        $api = new ConversationApi($client, $config, $headerSelector);
        return $api;
    }


    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation deleteConversationCannedMessage
     *
     * Delete a conversation canned message
     *
     * @param  int $conversation_canned_message_oid conversation_canned_message_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteConversationCannedMessage($conversation_canned_message_oid)
    {
        $this->deleteConversationCannedMessageWithHttpInfo($conversation_canned_message_oid);
    }


    /**
     * Operation deleteConversationCannedMessageWithHttpInfo
     *
     * Delete a conversation canned message
     *
     * @param  int $conversation_canned_message_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConversationCannedMessageWithHttpInfo($conversation_canned_message_oid)
    {
        $this->deleteConversationCannedMessageWithHttpInfoRetry(true ,   $conversation_canned_message_oid);
    }


    /**
     * Operation deleteConversationCannedMessageWithHttpInfoRetry
     *
     * Delete a conversation canned message
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  int $conversation_canned_message_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteConversationCannedMessageWithHttpInfoRetry($retry ,  $conversation_canned_message_oid)
    {
        $returnType = '';
        $request = $this->deleteConversationCannedMessageRequest($conversation_canned_message_oid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->deleteConversationCannedMessageWithHttpInfoRetry(false ,   $conversation_canned_message_oid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteConversationCannedMessageAsync
     *
     * Delete a conversation canned message
     *
     * @param  int $conversation_canned_message_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConversationCannedMessageAsync($conversation_canned_message_oid)
    {
        return $this->deleteConversationCannedMessageAsyncWithHttpInfo($conversation_canned_message_oid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteConversationCannedMessageAsyncWithHttpInfo
     *
     * Delete a conversation canned message
     *
     * @param  int $conversation_canned_message_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteConversationCannedMessageAsyncWithHttpInfo($conversation_canned_message_oid)
    {
        $returnType = '';
        $request = $this->deleteConversationCannedMessageRequest($conversation_canned_message_oid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteConversationCannedMessage'
     *
     * @param  int $conversation_canned_message_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteConversationCannedMessageRequest($conversation_canned_message_oid)
    {
        // verify the required parameter 'conversation_canned_message_oid' is set
        if ($conversation_canned_message_oid === null || (is_array($conversation_canned_message_oid) && count($conversation_canned_message_oid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_canned_message_oid when calling deleteConversationCannedMessage'
            );
        }

        $resourcePath = '/conversation/canned_messages/{conversation_canned_message_oid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_canned_message_oid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_canned_message_oid' . '}',
                ObjectSerializer::toPathValue($conversation_canned_message_oid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteDepartment
     *
     * Delete a conversation department
     *
     * @param  int $conversation_department_oid conversation_department_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteDepartment($conversation_department_oid)
    {
        $this->deleteDepartmentWithHttpInfo($conversation_department_oid);
    }


    /**
     * Operation deleteDepartmentWithHttpInfo
     *
     * Delete a conversation department
     *
     * @param  int $conversation_department_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDepartmentWithHttpInfo($conversation_department_oid)
    {
        $this->deleteDepartmentWithHttpInfoRetry(true ,   $conversation_department_oid);
    }


    /**
     * Operation deleteDepartmentWithHttpInfoRetry
     *
     * Delete a conversation department
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  int $conversation_department_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteDepartmentWithHttpInfoRetry($retry ,  $conversation_department_oid)
    {
        $returnType = '';
        $request = $this->deleteDepartmentRequest($conversation_department_oid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->deleteDepartmentWithHttpInfoRetry(false ,   $conversation_department_oid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteDepartmentAsync
     *
     * Delete a conversation department
     *
     * @param  int $conversation_department_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDepartmentAsync($conversation_department_oid)
    {
        return $this->deleteDepartmentAsyncWithHttpInfo($conversation_department_oid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteDepartmentAsyncWithHttpInfo
     *
     * Delete a conversation department
     *
     * @param  int $conversation_department_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteDepartmentAsyncWithHttpInfo($conversation_department_oid)
    {
        $returnType = '';
        $request = $this->deleteDepartmentRequest($conversation_department_oid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteDepartment'
     *
     * @param  int $conversation_department_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteDepartmentRequest($conversation_department_oid)
    {
        // verify the required parameter 'conversation_department_oid' is set
        if ($conversation_department_oid === null || (is_array($conversation_department_oid) && count($conversation_department_oid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_department_oid when calling deleteDepartment'
            );
        }

        $resourcePath = '/conversation/departments/{conversation_department_oid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_department_oid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_department_oid' . '}',
                ObjectSerializer::toPathValue($conversation_department_oid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteEngagement
     *
     * Delete a conversation engagement
     *
     * @param  int $conversation_engagement_oid conversation_engagement_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deleteEngagement($conversation_engagement_oid)
    {
        $this->deleteEngagementWithHttpInfo($conversation_engagement_oid);
    }


    /**
     * Operation deleteEngagementWithHttpInfo
     *
     * Delete a conversation engagement
     *
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteEngagementWithHttpInfo($conversation_engagement_oid)
    {
        $this->deleteEngagementWithHttpInfoRetry(true ,   $conversation_engagement_oid);
    }


    /**
     * Operation deleteEngagementWithHttpInfoRetry
     *
     * Delete a conversation engagement
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteEngagementWithHttpInfoRetry($retry ,  $conversation_engagement_oid)
    {
        $returnType = '';
        $request = $this->deleteEngagementRequest($conversation_engagement_oid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->deleteEngagementWithHttpInfoRetry(false ,   $conversation_engagement_oid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteEngagementAsync
     *
     * Delete a conversation engagement
     *
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEngagementAsync($conversation_engagement_oid)
    {
        return $this->deleteEngagementAsyncWithHttpInfo($conversation_engagement_oid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteEngagementAsyncWithHttpInfo
     *
     * Delete a conversation engagement
     *
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteEngagementAsyncWithHttpInfo($conversation_engagement_oid)
    {
        $returnType = '';
        $request = $this->deleteEngagementRequest($conversation_engagement_oid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteEngagement'
     *
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteEngagementRequest($conversation_engagement_oid)
    {
        // verify the required parameter 'conversation_engagement_oid' is set
        if ($conversation_engagement_oid === null || (is_array($conversation_engagement_oid) && count($conversation_engagement_oid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_engagement_oid when calling deleteEngagement'
            );
        }

        $resourcePath = '/conversation/engagements/{conversation_engagement_oid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_engagement_oid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_engagement_oid' . '}',
                ObjectSerializer::toPathValue($conversation_engagement_oid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePbxAgent
     *
     * Delete pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid conversation_pbx_agent_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAgentResponse
     */
    public function deletePbxAgent($conversation_pbx_agent_uuid)
    {
        list($response) = $this->deletePbxAgentWithHttpInfo($conversation_pbx_agent_uuid);
        return $response;
    }


    /**
     * Operation deletePbxAgentWithHttpInfo
     *
     * Delete pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxAgentWithHttpInfo($conversation_pbx_agent_uuid)
    {
        return $this->deletePbxAgentWithHttpInfoRetry(true ,   $conversation_pbx_agent_uuid);
    }


    /**
     * Operation deletePbxAgentWithHttpInfoRetry
     *
     * Delete pbx agent
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxAgentWithHttpInfoRetry($retry ,  $conversation_pbx_agent_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentResponse';
        $request = $this->deletePbxAgentRequest($conversation_pbx_agent_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->deletePbxAgentWithHttpInfoRetry(false ,   $conversation_pbx_agent_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAgentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePbxAgentAsync
     *
     * Delete pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxAgentAsync($conversation_pbx_agent_uuid)
    {
        return $this->deletePbxAgentAsyncWithHttpInfo($conversation_pbx_agent_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePbxAgentAsyncWithHttpInfo
     *
     * Delete pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxAgentAsyncWithHttpInfo($conversation_pbx_agent_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentResponse';
        $request = $this->deletePbxAgentRequest($conversation_pbx_agent_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePbxAgent'
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePbxAgentRequest($conversation_pbx_agent_uuid)
    {
        // verify the required parameter 'conversation_pbx_agent_uuid' is set
        if ($conversation_pbx_agent_uuid === null || (is_array($conversation_pbx_agent_uuid) && count($conversation_pbx_agent_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_agent_uuid when calling deletePbxAgent'
            );
        }

        $resourcePath = '/conversation/pbx/agent/{conversationPbxAgentUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_agent_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxAgentUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_agent_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePbxAgentVoicemail
     *
     * Delete Agent Voicemail
     *
     * @param  string $recording_sid recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function deletePbxAgentVoicemail($recording_sid)
    {
        $this->deletePbxAgentVoicemailWithHttpInfo($recording_sid);
    }


    /**
     * Operation deletePbxAgentVoicemailWithHttpInfo
     *
     * Delete Agent Voicemail
     *
     * @param  string $recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxAgentVoicemailWithHttpInfo($recording_sid)
    {
        $this->deletePbxAgentVoicemailWithHttpInfoRetry(true ,   $recording_sid);
    }


    /**
     * Operation deletePbxAgentVoicemailWithHttpInfoRetry
     *
     * Delete Agent Voicemail
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxAgentVoicemailWithHttpInfoRetry($retry ,  $recording_sid)
    {
        $returnType = '';
        $request = $this->deletePbxAgentVoicemailRequest($recording_sid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->deletePbxAgentVoicemailWithHttpInfoRetry(false ,   $recording_sid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePbxAgentVoicemailAsync
     *
     * Delete Agent Voicemail
     *
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxAgentVoicemailAsync($recording_sid)
    {
        return $this->deletePbxAgentVoicemailAsyncWithHttpInfo($recording_sid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePbxAgentVoicemailAsyncWithHttpInfo
     *
     * Delete Agent Voicemail
     *
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxAgentVoicemailAsyncWithHttpInfo($recording_sid)
    {
        $returnType = '';
        $request = $this->deletePbxAgentVoicemailRequest($recording_sid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePbxAgentVoicemail'
     *
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePbxAgentVoicemailRequest($recording_sid)
    {
        // verify the required parameter 'recording_sid' is set
        if ($recording_sid === null || (is_array($recording_sid) && count($recording_sid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_sid when calling deletePbxAgentVoicemail'
            );
        }

        $resourcePath = '/conversation/pbx/agent/voicemails/{recording_sid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($recording_sid !== null) {
            $resourcePath = str_replace(
                '{' . 'recording_sid' . '}',
                ObjectSerializer::toPathValue($recording_sid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePbxAudio
     *
     * Delete pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid conversation_pbx_audio_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAudioResponse
     */
    public function deletePbxAudio($conversation_pbx_audio_uuid)
    {
        list($response) = $this->deletePbxAudioWithHttpInfo($conversation_pbx_audio_uuid);
        return $response;
    }


    /**
     * Operation deletePbxAudioWithHttpInfo
     *
     * Delete pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudioResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxAudioWithHttpInfo($conversation_pbx_audio_uuid)
    {
        return $this->deletePbxAudioWithHttpInfoRetry(true ,   $conversation_pbx_audio_uuid);
    }


    /**
     * Operation deletePbxAudioWithHttpInfoRetry
     *
     * Delete pbx audio
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudioResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxAudioWithHttpInfoRetry($retry ,  $conversation_pbx_audio_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudioResponse';
        $request = $this->deletePbxAudioRequest($conversation_pbx_audio_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->deletePbxAudioWithHttpInfoRetry(false ,   $conversation_pbx_audio_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAudioResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePbxAudioAsync
     *
     * Delete pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxAudioAsync($conversation_pbx_audio_uuid)
    {
        return $this->deletePbxAudioAsyncWithHttpInfo($conversation_pbx_audio_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePbxAudioAsyncWithHttpInfo
     *
     * Delete pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxAudioAsyncWithHttpInfo($conversation_pbx_audio_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudioResponse';
        $request = $this->deletePbxAudioRequest($conversation_pbx_audio_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePbxAudio'
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePbxAudioRequest($conversation_pbx_audio_uuid)
    {
        // verify the required parameter 'conversation_pbx_audio_uuid' is set
        if ($conversation_pbx_audio_uuid === null || (is_array($conversation_pbx_audio_uuid) && count($conversation_pbx_audio_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_audio_uuid when calling deletePbxAudio'
            );
        }

        $resourcePath = '/conversation/pbx/audio/{conversationPbxAudioUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_audio_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxAudioUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_audio_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePbxMenu
     *
     * Delete pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid conversation_pbx_menu_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxMenuResponse
     */
    public function deletePbxMenu($conversation_pbx_menu_uuid)
    {
        list($response) = $this->deletePbxMenuWithHttpInfo($conversation_pbx_menu_uuid);
        return $response;
    }


    /**
     * Operation deletePbxMenuWithHttpInfo
     *
     * Delete pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxMenuWithHttpInfo($conversation_pbx_menu_uuid)
    {
        return $this->deletePbxMenuWithHttpInfoRetry(true ,   $conversation_pbx_menu_uuid);
    }


    /**
     * Operation deletePbxMenuWithHttpInfoRetry
     *
     * Delete pbx menu
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxMenuWithHttpInfoRetry($retry ,  $conversation_pbx_menu_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenuResponse';
        $request = $this->deletePbxMenuRequest($conversation_pbx_menu_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->deletePbxMenuWithHttpInfoRetry(false ,   $conversation_pbx_menu_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxMenuResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePbxMenuAsync
     *
     * Delete pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxMenuAsync($conversation_pbx_menu_uuid)
    {
        return $this->deletePbxMenuAsyncWithHttpInfo($conversation_pbx_menu_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePbxMenuAsyncWithHttpInfo
     *
     * Delete pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxMenuAsyncWithHttpInfo($conversation_pbx_menu_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenuResponse';
        $request = $this->deletePbxMenuRequest($conversation_pbx_menu_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePbxMenu'
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePbxMenuRequest($conversation_pbx_menu_uuid)
    {
        // verify the required parameter 'conversation_pbx_menu_uuid' is set
        if ($conversation_pbx_menu_uuid === null || (is_array($conversation_pbx_menu_uuid) && count($conversation_pbx_menu_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_menu_uuid when calling deletePbxMenu'
            );
        }

        $resourcePath = '/conversation/pbx/menu/{conversationPbxMenuUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_menu_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxMenuUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_menu_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePbxPhoneNumber
     *
     * Delete pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid conversation_pbx_phone_number_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxPhoneNumberResponse
     */
    public function deletePbxPhoneNumber($conversation_pbx_phone_number_uuid)
    {
        list($response) = $this->deletePbxPhoneNumberWithHttpInfo($conversation_pbx_phone_number_uuid);
        return $response;
    }


    /**
     * Operation deletePbxPhoneNumberWithHttpInfo
     *
     * Delete pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxPhoneNumberWithHttpInfo($conversation_pbx_phone_number_uuid)
    {
        return $this->deletePbxPhoneNumberWithHttpInfoRetry(true ,   $conversation_pbx_phone_number_uuid);
    }


    /**
     * Operation deletePbxPhoneNumberWithHttpInfoRetry
     *
     * Delete pbx phoneNumber
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxPhoneNumberWithHttpInfoRetry($retry ,  $conversation_pbx_phone_number_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumberResponse';
        $request = $this->deletePbxPhoneNumberRequest($conversation_pbx_phone_number_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->deletePbxPhoneNumberWithHttpInfoRetry(false ,   $conversation_pbx_phone_number_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxPhoneNumberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePbxPhoneNumberAsync
     *
     * Delete pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxPhoneNumberAsync($conversation_pbx_phone_number_uuid)
    {
        return $this->deletePbxPhoneNumberAsyncWithHttpInfo($conversation_pbx_phone_number_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePbxPhoneNumberAsyncWithHttpInfo
     *
     * Delete pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxPhoneNumberAsyncWithHttpInfo($conversation_pbx_phone_number_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumberResponse';
        $request = $this->deletePbxPhoneNumberRequest($conversation_pbx_phone_number_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePbxPhoneNumber'
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePbxPhoneNumberRequest($conversation_pbx_phone_number_uuid)
    {
        // verify the required parameter 'conversation_pbx_phone_number_uuid' is set
        if ($conversation_pbx_phone_number_uuid === null || (is_array($conversation_pbx_phone_number_uuid) && count($conversation_pbx_phone_number_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_phone_number_uuid when calling deletePbxPhoneNumber'
            );
        }

        $resourcePath = '/conversation/pbx/phone_number/{conversationPbxPhoneNumberUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_phone_number_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxPhoneNumberUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_phone_number_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePbxQueue
     *
     * Delete pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid conversation_pbx_queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxQueueResponse
     */
    public function deletePbxQueue($conversation_pbx_queue_uuid)
    {
        list($response) = $this->deletePbxQueueWithHttpInfo($conversation_pbx_queue_uuid);
        return $response;
    }


    /**
     * Operation deletePbxQueueWithHttpInfo
     *
     * Delete pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueueResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxQueueWithHttpInfo($conversation_pbx_queue_uuid)
    {
        return $this->deletePbxQueueWithHttpInfoRetry(true ,   $conversation_pbx_queue_uuid);
    }


    /**
     * Operation deletePbxQueueWithHttpInfoRetry
     *
     * Delete pbx queue
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueueResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxQueueWithHttpInfoRetry($retry ,  $conversation_pbx_queue_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueueResponse';
        $request = $this->deletePbxQueueRequest($conversation_pbx_queue_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->deletePbxQueueWithHttpInfoRetry(false ,   $conversation_pbx_queue_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxQueueResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePbxQueueAsync
     *
     * Delete pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxQueueAsync($conversation_pbx_queue_uuid)
    {
        return $this->deletePbxQueueAsyncWithHttpInfo($conversation_pbx_queue_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePbxQueueAsyncWithHttpInfo
     *
     * Delete pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxQueueAsyncWithHttpInfo($conversation_pbx_queue_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueueResponse';
        $request = $this->deletePbxQueueRequest($conversation_pbx_queue_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePbxQueue'
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePbxQueueRequest($conversation_pbx_queue_uuid)
    {
        // verify the required parameter 'conversation_pbx_queue_uuid' is set
        if ($conversation_pbx_queue_uuid === null || (is_array($conversation_pbx_queue_uuid) && count($conversation_pbx_queue_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_queue_uuid when calling deletePbxQueue'
            );
        }

        $resourcePath = '/conversation/pbx/queue/{conversationPbxQueueUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_queue_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxQueueUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_queue_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePbxTimeBased
     *
     * Delete pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid conversation_pbx_time_based_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeBasedResponse
     */
    public function deletePbxTimeBased($conversation_pbx_time_based_uuid)
    {
        list($response) = $this->deletePbxTimeBasedWithHttpInfo($conversation_pbx_time_based_uuid);
        return $response;
    }


    /**
     * Operation deletePbxTimeBasedWithHttpInfo
     *
     * Delete pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxTimeBasedWithHttpInfo($conversation_pbx_time_based_uuid)
    {
        return $this->deletePbxTimeBasedWithHttpInfoRetry(true ,   $conversation_pbx_time_based_uuid);
    }


    /**
     * Operation deletePbxTimeBasedWithHttpInfoRetry
     *
     * Delete pbx timeBased
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxTimeBasedWithHttpInfoRetry($retry ,  $conversation_pbx_time_based_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedResponse';
        $request = $this->deletePbxTimeBasedRequest($conversation_pbx_time_based_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->deletePbxTimeBasedWithHttpInfoRetry(false ,   $conversation_pbx_time_based_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeBasedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePbxTimeBasedAsync
     *
     * Delete pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxTimeBasedAsync($conversation_pbx_time_based_uuid)
    {
        return $this->deletePbxTimeBasedAsyncWithHttpInfo($conversation_pbx_time_based_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePbxTimeBasedAsyncWithHttpInfo
     *
     * Delete pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxTimeBasedAsyncWithHttpInfo($conversation_pbx_time_based_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedResponse';
        $request = $this->deletePbxTimeBasedRequest($conversation_pbx_time_based_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePbxTimeBased'
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePbxTimeBasedRequest($conversation_pbx_time_based_uuid)
    {
        // verify the required parameter 'conversation_pbx_time_based_uuid' is set
        if ($conversation_pbx_time_based_uuid === null || (is_array($conversation_pbx_time_based_uuid) && count($conversation_pbx_time_based_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_time_based_uuid when calling deletePbxTimeBased'
            );
        }

        $resourcePath = '/conversation/pbx/time_based/{conversationPbxTimeBasedUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_time_based_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxTimeBasedUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_time_based_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePbxTimeRange
     *
     * Delete pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid conversation_pbx_time_range_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeRangeResponse
     */
    public function deletePbxTimeRange($conversation_pbx_time_range_uuid)
    {
        list($response) = $this->deletePbxTimeRangeWithHttpInfo($conversation_pbx_time_range_uuid);
        return $response;
    }


    /**
     * Operation deletePbxTimeRangeWithHttpInfo
     *
     * Delete pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxTimeRangeWithHttpInfo($conversation_pbx_time_range_uuid)
    {
        return $this->deletePbxTimeRangeWithHttpInfoRetry(true ,   $conversation_pbx_time_range_uuid);
    }


    /**
     * Operation deletePbxTimeRangeWithHttpInfoRetry
     *
     * Delete pbx timeRange
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxTimeRangeWithHttpInfoRetry($retry ,  $conversation_pbx_time_range_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangeResponse';
        $request = $this->deletePbxTimeRangeRequest($conversation_pbx_time_range_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->deletePbxTimeRangeWithHttpInfoRetry(false ,   $conversation_pbx_time_range_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeRangeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePbxTimeRangeAsync
     *
     * Delete pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxTimeRangeAsync($conversation_pbx_time_range_uuid)
    {
        return $this->deletePbxTimeRangeAsyncWithHttpInfo($conversation_pbx_time_range_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePbxTimeRangeAsyncWithHttpInfo
     *
     * Delete pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxTimeRangeAsyncWithHttpInfo($conversation_pbx_time_range_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangeResponse';
        $request = $this->deletePbxTimeRangeRequest($conversation_pbx_time_range_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePbxTimeRange'
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePbxTimeRangeRequest($conversation_pbx_time_range_uuid)
    {
        // verify the required parameter 'conversation_pbx_time_range_uuid' is set
        if ($conversation_pbx_time_range_uuid === null || (is_array($conversation_pbx_time_range_uuid) && count($conversation_pbx_time_range_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_time_range_uuid when calling deletePbxTimeRange'
            );
        }

        $resourcePath = '/conversation/pbx/time_range/{conversationPbxTimeRangeUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_time_range_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxTimeRangeUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_time_range_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deletePbxVoicemailMailbox
     *
     * Delete pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse
     */
    public function deletePbxVoicemailMailbox($conversation_pbx_voicemail_mailbox_uuid)
    {
        list($response) = $this->deletePbxVoicemailMailboxWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid);
        return $response;
    }


    /**
     * Operation deletePbxVoicemailMailboxWithHttpInfo
     *
     * Delete pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxVoicemailMailboxWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid)
    {
        return $this->deletePbxVoicemailMailboxWithHttpInfoRetry(true ,   $conversation_pbx_voicemail_mailbox_uuid);
    }


    /**
     * Operation deletePbxVoicemailMailboxWithHttpInfoRetry
     *
     * Delete pbx voicemailMailbox
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePbxVoicemailMailboxWithHttpInfoRetry($retry ,  $conversation_pbx_voicemail_mailbox_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse';
        $request = $this->deletePbxVoicemailMailboxRequest($conversation_pbx_voicemail_mailbox_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->deletePbxVoicemailMailboxWithHttpInfoRetry(false ,   $conversation_pbx_voicemail_mailbox_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deletePbxVoicemailMailboxAsync
     *
     * Delete pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxVoicemailMailboxAsync($conversation_pbx_voicemail_mailbox_uuid)
    {
        return $this->deletePbxVoicemailMailboxAsyncWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deletePbxVoicemailMailboxAsyncWithHttpInfo
     *
     * Delete pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deletePbxVoicemailMailboxAsyncWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse';
        $request = $this->deletePbxVoicemailMailboxRequest($conversation_pbx_voicemail_mailbox_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deletePbxVoicemailMailbox'
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deletePbxVoicemailMailboxRequest($conversation_pbx_voicemail_mailbox_uuid)
    {
        // verify the required parameter 'conversation_pbx_voicemail_mailbox_uuid' is set
        if ($conversation_pbx_voicemail_mailbox_uuid === null || (is_array($conversation_pbx_voicemail_mailbox_uuid) && count($conversation_pbx_voicemail_mailbox_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_voicemail_mailbox_uuid when calling deletePbxVoicemailMailbox'
            );
        }

        $resourcePath = '/conversation/pbx/voicemail_mailbox/{conversationPbxVoicemailMailboxUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_voicemail_mailbox_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxVoicemailMailboxUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_voicemail_mailbox_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgentKeepAlive
     *
     * Agent keep alive
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function getAgentKeepAlive()
    {
        $this->getAgentKeepAliveWithHttpInfo();
    }


    /**
     * Operation getAgentKeepAliveWithHttpInfo
     *
     * Agent keep alive
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentKeepAliveWithHttpInfo()
    {
        $this->getAgentKeepAliveWithHttpInfoRetry(true );
    }


    /**
     * Operation getAgentKeepAliveWithHttpInfoRetry
     *
     * Agent keep alive
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentKeepAliveWithHttpInfoRetry($retry )
    {
        $returnType = '';
        $request = $this->getAgentKeepAliveRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->getAgentKeepAliveWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAgentKeepAliveAsync
     *
     * Agent keep alive
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentKeepAliveAsync()
    {
        return $this->getAgentKeepAliveAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgentKeepAliveAsyncWithHttpInfo
     *
     * Agent keep alive
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentKeepAliveAsyncWithHttpInfo()
    {
        $returnType = '';
        $request = $this->getAgentKeepAliveRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgentKeepAlive'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAgentKeepAliveRequest()
    {

        $resourcePath = '/conversation/agent/keepalive';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgentProfile
     *
     * Get agent profile
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationAgentProfileResponse
     */
    public function getAgentProfile()
    {
        list($response) = $this->getAgentProfileWithHttpInfo();
        return $response;
    }


    /**
     * Operation getAgentProfileWithHttpInfo
     *
     * Get agent profile
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationAgentProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentProfileWithHttpInfo()
    {
        return $this->getAgentProfileWithHttpInfoRetry(true );
    }


    /**
     * Operation getAgentProfileWithHttpInfoRetry
     *
     * Get agent profile
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationAgentProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentProfileWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationAgentProfileResponse';
        $request = $this->getAgentProfileRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getAgentProfileWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationAgentProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAgentProfileAsync
     *
     * Get agent profile
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentProfileAsync()
    {
        return $this->getAgentProfileAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgentProfileAsyncWithHttpInfo
     *
     * Get agent profile
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentProfileAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationAgentProfileResponse';
        $request = $this->getAgentProfileRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgentProfile'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAgentProfileRequest()
    {

        $resourcePath = '/conversation/agent/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAgentWebsocketAuthorization
     *
     * Get agent websocket authorization
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationAgentAuthResponse
     */
    public function getAgentWebsocketAuthorization()
    {
        list($response) = $this->getAgentWebsocketAuthorizationWithHttpInfo();
        return $response;
    }


    /**
     * Operation getAgentWebsocketAuthorizationWithHttpInfo
     *
     * Get agent websocket authorization
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationAgentAuthResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentWebsocketAuthorizationWithHttpInfo()
    {
        return $this->getAgentWebsocketAuthorizationWithHttpInfoRetry(true );
    }


    /**
     * Operation getAgentWebsocketAuthorizationWithHttpInfoRetry
     *
     * Get agent websocket authorization
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationAgentAuthResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAgentWebsocketAuthorizationWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationAgentAuthResponse';
        $request = $this->getAgentWebsocketAuthorizationRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getAgentWebsocketAuthorizationWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationAgentAuthResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getAgentWebsocketAuthorizationAsync
     *
     * Get agent websocket authorization
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentWebsocketAuthorizationAsync()
    {
        return $this->getAgentWebsocketAuthorizationAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAgentWebsocketAuthorizationAsyncWithHttpInfo
     *
     * Get agent websocket authorization
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAgentWebsocketAuthorizationAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationAgentAuthResponse';
        $request = $this->getAgentWebsocketAuthorizationRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAgentWebsocketAuthorization'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getAgentWebsocketAuthorizationRequest()
    {

        $resourcePath = '/conversation/agent/auth';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversation
     *
     * Retrieve a conversation
     *
     * @param  string $conversation_uuid conversation_uuid (required)
     * @param  int $limit limit (optional)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationResponse
     */
    public function getConversation($conversation_uuid, $limit = null)
    {
        list($response) = $this->getConversationWithHttpInfo($conversation_uuid, $limit);
        return $response;
    }


    /**
     * Operation getConversationWithHttpInfo
     *
     * Retrieve a conversation
     *
     * @param  string $conversation_uuid (required)
     * @param  int $limit (optional)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationWithHttpInfo($conversation_uuid, $limit = null)
    {
        return $this->getConversationWithHttpInfoRetry(true ,   $conversation_uuid,   $limit);
    }


    /**
     * Operation getConversationWithHttpInfoRetry
     *
     * Retrieve a conversation
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_uuid (required)
     * @param  int $limit (optional)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationWithHttpInfoRetry($retry ,  $conversation_uuid,  $limit = null)
    {
        $returnType = '\ultracart\v2\models\ConversationResponse';
        $request = $this->getConversationRequest($conversation_uuid, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationWithHttpInfoRetry(false ,   $conversation_uuid,   $limit);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationAsync
     *
     * Retrieve a conversation
     *
     * @param  string $conversation_uuid (required)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationAsync($conversation_uuid, $limit = null)
    {
        return $this->getConversationAsyncWithHttpInfo($conversation_uuid, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationAsyncWithHttpInfo
     *
     * Retrieve a conversation
     *
     * @param  string $conversation_uuid (required)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationAsyncWithHttpInfo($conversation_uuid, $limit = null)
    {
        $returnType = '\ultracart\v2\models\ConversationResponse';
        $request = $this->getConversationRequest($conversation_uuid, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversation'
     *
     * @param  string $conversation_uuid (required)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationRequest($conversation_uuid, $limit = null)
    {
        // verify the required parameter 'conversation_uuid' is set
        if ($conversation_uuid === null || (is_array($conversation_uuid) && count($conversation_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_uuid when calling getConversation'
            );
        }

        $resourcePath = '/conversation/conversations/{conversation_uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }

        // path params
        if ($conversation_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_uuid' . '}',
                ObjectSerializer::toPathValue($conversation_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationCannedMessages
     *
     * Retrieve a list of canned messages ordered by short_code
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationCannedMessagesResponse
     */
    public function getConversationCannedMessages()
    {
        list($response) = $this->getConversationCannedMessagesWithHttpInfo();
        return $response;
    }


    /**
     * Operation getConversationCannedMessagesWithHttpInfo
     *
     * Retrieve a list of canned messages ordered by short_code
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationCannedMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationCannedMessagesWithHttpInfo()
    {
        return $this->getConversationCannedMessagesWithHttpInfoRetry(true );
    }


    /**
     * Operation getConversationCannedMessagesWithHttpInfoRetry
     *
     * Retrieve a list of canned messages ordered by short_code
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationCannedMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationCannedMessagesWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationCannedMessagesResponse';
        $request = $this->getConversationCannedMessagesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationCannedMessagesWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationCannedMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationCannedMessagesAsync
     *
     * Retrieve a list of canned messages ordered by short_code
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationCannedMessagesAsync()
    {
        return $this->getConversationCannedMessagesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationCannedMessagesAsyncWithHttpInfo
     *
     * Retrieve a list of canned messages ordered by short_code
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationCannedMessagesAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationCannedMessagesResponse';
        $request = $this->getConversationCannedMessagesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationCannedMessages'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationCannedMessagesRequest()
    {

        $resourcePath = '/conversation/canned_messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationContext
     *
     * Get a webchat conversation context
     *
     * @param  string $conversation_uuid conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationWebchatContext
     */
    public function getConversationContext($conversation_uuid)
    {
        list($response) = $this->getConversationContextWithHttpInfo($conversation_uuid);
        return $response;
    }


    /**
     * Operation getConversationContextWithHttpInfo
     *
     * Get a webchat conversation context
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationWebchatContext, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationContextWithHttpInfo($conversation_uuid)
    {
        return $this->getConversationContextWithHttpInfoRetry(true ,   $conversation_uuid);
    }


    /**
     * Operation getConversationContextWithHttpInfoRetry
     *
     * Get a webchat conversation context
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationWebchatContext, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationContextWithHttpInfoRetry($retry ,  $conversation_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationWebchatContext';
        $request = $this->getConversationContextRequest($conversation_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationContextWithHttpInfoRetry(false ,   $conversation_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationWebchatContext',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationContextAsync
     *
     * Get a webchat conversation context
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationContextAsync($conversation_uuid)
    {
        return $this->getConversationContextAsyncWithHttpInfo($conversation_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationContextAsyncWithHttpInfo
     *
     * Get a webchat conversation context
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationContextAsyncWithHttpInfo($conversation_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationWebchatContext';
        $request = $this->getConversationContextRequest($conversation_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationContext'
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationContextRequest($conversation_uuid)
    {
        // verify the required parameter 'conversation_uuid' is set
        if ($conversation_uuid === null || (is_array($conversation_uuid) && count($conversation_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_uuid when calling getConversationContext'
            );
        }

        $resourcePath = '/conversation/conversations/{conversation_uuid}/context';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_uuid' . '}',
                ObjectSerializer::toPathValue($conversation_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationDepartmentMemberList
     *
     * Retrieve a list of possible department members
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationDepartmentMembersResponse
     */
    public function getConversationDepartmentMemberList()
    {
        list($response) = $this->getConversationDepartmentMemberListWithHttpInfo();
        return $response;
    }


    /**
     * Operation getConversationDepartmentMemberListWithHttpInfo
     *
     * Retrieve a list of possible department members
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationDepartmentMembersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationDepartmentMemberListWithHttpInfo()
    {
        return $this->getConversationDepartmentMemberListWithHttpInfoRetry(true );
    }


    /**
     * Operation getConversationDepartmentMemberListWithHttpInfoRetry
     *
     * Retrieve a list of possible department members
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationDepartmentMembersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationDepartmentMemberListWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationDepartmentMembersResponse';
        $request = $this->getConversationDepartmentMemberListRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationDepartmentMemberListWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationDepartmentMembersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationDepartmentMemberListAsync
     *
     * Retrieve a list of possible department members
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationDepartmentMemberListAsync()
    {
        return $this->getConversationDepartmentMemberListAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationDepartmentMemberListAsyncWithHttpInfo
     *
     * Retrieve a list of possible department members
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationDepartmentMemberListAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationDepartmentMembersResponse';
        $request = $this->getConversationDepartmentMemberListRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationDepartmentMemberList'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationDepartmentMemberListRequest()
    {

        $resourcePath = '/conversation/department_members';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationDepartments
     *
     * Retrieve a list of departments ordered by name
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationDepartmentsResponse
     */
    public function getConversationDepartments()
    {
        list($response) = $this->getConversationDepartmentsWithHttpInfo();
        return $response;
    }


    /**
     * Operation getConversationDepartmentsWithHttpInfo
     *
     * Retrieve a list of departments ordered by name
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationDepartmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationDepartmentsWithHttpInfo()
    {
        return $this->getConversationDepartmentsWithHttpInfoRetry(true );
    }


    /**
     * Operation getConversationDepartmentsWithHttpInfoRetry
     *
     * Retrieve a list of departments ordered by name
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationDepartmentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationDepartmentsWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationDepartmentsResponse';
        $request = $this->getConversationDepartmentsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationDepartmentsWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationDepartmentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationDepartmentsAsync
     *
     * Retrieve a list of departments ordered by name
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationDepartmentsAsync()
    {
        return $this->getConversationDepartmentsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationDepartmentsAsyncWithHttpInfo
     *
     * Retrieve a list of departments ordered by name
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationDepartmentsAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationDepartmentsResponse';
        $request = $this->getConversationDepartmentsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationDepartments'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationDepartmentsRequest()
    {

        $resourcePath = '/conversation/departments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationEngagement
     *
     * Retrieve an engagement
     *
     * @param  int $conversation_engagement_oid conversation_engagement_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationEngagementResponse
     */
    public function getConversationEngagement($conversation_engagement_oid)
    {
        list($response) = $this->getConversationEngagementWithHttpInfo($conversation_engagement_oid);
        return $response;
    }


    /**
     * Operation getConversationEngagementWithHttpInfo
     *
     * Retrieve an engagement
     *
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationEngagementResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationEngagementWithHttpInfo($conversation_engagement_oid)
    {
        return $this->getConversationEngagementWithHttpInfoRetry(true ,   $conversation_engagement_oid);
    }


    /**
     * Operation getConversationEngagementWithHttpInfoRetry
     *
     * Retrieve an engagement
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationEngagementResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationEngagementWithHttpInfoRetry($retry ,  $conversation_engagement_oid)
    {
        $returnType = '\ultracart\v2\models\ConversationEngagementResponse';
        $request = $this->getConversationEngagementRequest($conversation_engagement_oid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationEngagementWithHttpInfoRetry(false ,   $conversation_engagement_oid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationEngagementResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationEngagementAsync
     *
     * Retrieve an engagement
     *
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationEngagementAsync($conversation_engagement_oid)
    {
        return $this->getConversationEngagementAsyncWithHttpInfo($conversation_engagement_oid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationEngagementAsyncWithHttpInfo
     *
     * Retrieve an engagement
     *
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationEngagementAsyncWithHttpInfo($conversation_engagement_oid)
    {
        $returnType = '\ultracart\v2\models\ConversationEngagementResponse';
        $request = $this->getConversationEngagementRequest($conversation_engagement_oid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationEngagement'
     *
     * @param  int $conversation_engagement_oid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationEngagementRequest($conversation_engagement_oid)
    {
        // verify the required parameter 'conversation_engagement_oid' is set
        if ($conversation_engagement_oid === null || (is_array($conversation_engagement_oid) && count($conversation_engagement_oid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_engagement_oid when calling getConversationEngagement'
            );
        }

        $resourcePath = '/conversation/engagements/{conversation_engagement_oid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_engagement_oid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_engagement_oid' . '}',
                ObjectSerializer::toPathValue($conversation_engagement_oid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationEngagements
     *
     * Retrieve a list of engagements ordered by name
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationEngagementsResponse
     */
    public function getConversationEngagements()
    {
        list($response) = $this->getConversationEngagementsWithHttpInfo();
        return $response;
    }


    /**
     * Operation getConversationEngagementsWithHttpInfo
     *
     * Retrieve a list of engagements ordered by name
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationEngagementsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationEngagementsWithHttpInfo()
    {
        return $this->getConversationEngagementsWithHttpInfoRetry(true );
    }


    /**
     * Operation getConversationEngagementsWithHttpInfoRetry
     *
     * Retrieve a list of engagements ordered by name
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationEngagementsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationEngagementsWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationEngagementsResponse';
        $request = $this->getConversationEngagementsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationEngagementsWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationEngagementsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationEngagementsAsync
     *
     * Retrieve a list of engagements ordered by name
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationEngagementsAsync()
    {
        return $this->getConversationEngagementsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationEngagementsAsyncWithHttpInfo
     *
     * Retrieve a list of engagements ordered by name
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationEngagementsAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationEngagementsResponse';
        $request = $this->getConversationEngagementsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationEngagements'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationEngagementsRequest()
    {

        $resourcePath = '/conversation/engagements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationMessages
     *
     * Retrieve conversation messages
     *
     * @param  string $conversation_uuid conversation_uuid (required)
     * @param  int $since since (required)
     * @param  int $limit limit (optional)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationMessagesResponse
     */
    public function getConversationMessages($conversation_uuid, $since, $limit = null)
    {
        list($response) = $this->getConversationMessagesWithHttpInfo($conversation_uuid, $since, $limit);
        return $response;
    }


    /**
     * Operation getConversationMessagesWithHttpInfo
     *
     * Retrieve conversation messages
     *
     * @param  string $conversation_uuid (required)
     * @param  int $since (required)
     * @param  int $limit (optional)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationMessagesWithHttpInfo($conversation_uuid, $since, $limit = null)
    {
        return $this->getConversationMessagesWithHttpInfoRetry(true ,   $conversation_uuid,   $since,   $limit);
    }


    /**
     * Operation getConversationMessagesWithHttpInfoRetry
     *
     * Retrieve conversation messages
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_uuid (required)
     * @param  int $since (required)
     * @param  int $limit (optional)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationMessagesWithHttpInfoRetry($retry ,  $conversation_uuid,  $since,  $limit = null)
    {
        $returnType = '\ultracart\v2\models\ConversationMessagesResponse';
        $request = $this->getConversationMessagesRequest($conversation_uuid, $since, $limit);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationMessagesWithHttpInfoRetry(false ,   $conversation_uuid,   $since,   $limit);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationMessagesAsync
     *
     * Retrieve conversation messages
     *
     * @param  string $conversation_uuid (required)
     * @param  int $since (required)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationMessagesAsync($conversation_uuid, $since, $limit = null)
    {
        return $this->getConversationMessagesAsyncWithHttpInfo($conversation_uuid, $since, $limit)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationMessagesAsyncWithHttpInfo
     *
     * Retrieve conversation messages
     *
     * @param  string $conversation_uuid (required)
     * @param  int $since (required)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationMessagesAsyncWithHttpInfo($conversation_uuid, $since, $limit = null)
    {
        $returnType = '\ultracart\v2\models\ConversationMessagesResponse';
        $request = $this->getConversationMessagesRequest($conversation_uuid, $since, $limit);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationMessages'
     *
     * @param  string $conversation_uuid (required)
     * @param  int $since (required)
     * @param  int $limit (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationMessagesRequest($conversation_uuid, $since, $limit = null)
    {
        // verify the required parameter 'conversation_uuid' is set
        if ($conversation_uuid === null || (is_array($conversation_uuid) && count($conversation_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_uuid when calling getConversationMessages'
            );
        }
        // verify the required parameter 'since' is set
        if ($since === null || (is_array($since) && count($since) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $since when calling getConversationMessages'
            );
        }

        $resourcePath = '/conversation/conversations/{conversation_uuid}/messages/{since}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($limit !== null) {
            $queryParams['limit'] = ObjectSerializer::toQueryValue($limit);
        }

        // path params
        if ($conversation_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_uuid' . '}',
                ObjectSerializer::toPathValue($conversation_uuid),
                $resourcePath
            );
        }
        // path params
        if ($since !== null) {
            $resourcePath = str_replace(
                '{' . 'since' . '}',
                ObjectSerializer::toPathValue($since),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationMultimediaUploadUrl
     *
     * Get a presigned conversation multimedia upload URL
     *
     * @param  string $extension extension (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationMultimediaUploadUrlResponse
     */
    public function getConversationMultimediaUploadUrl($extension)
    {
        list($response) = $this->getConversationMultimediaUploadUrlWithHttpInfo($extension);
        return $response;
    }


    /**
     * Operation getConversationMultimediaUploadUrlWithHttpInfo
     *
     * Get a presigned conversation multimedia upload URL
     *
     * @param  string $extension (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationMultimediaUploadUrlResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationMultimediaUploadUrlWithHttpInfo($extension)
    {
        return $this->getConversationMultimediaUploadUrlWithHttpInfoRetry(true ,   $extension);
    }


    /**
     * Operation getConversationMultimediaUploadUrlWithHttpInfoRetry
     *
     * Get a presigned conversation multimedia upload URL
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $extension (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationMultimediaUploadUrlResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationMultimediaUploadUrlWithHttpInfoRetry($retry ,  $extension)
    {
        $returnType = '\ultracart\v2\models\ConversationMultimediaUploadUrlResponse';
        $request = $this->getConversationMultimediaUploadUrlRequest($extension);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationMultimediaUploadUrlWithHttpInfoRetry(false ,   $extension);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationMultimediaUploadUrlResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationMultimediaUploadUrlAsync
     *
     * Get a presigned conversation multimedia upload URL
     *
     * @param  string $extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationMultimediaUploadUrlAsync($extension)
    {
        return $this->getConversationMultimediaUploadUrlAsyncWithHttpInfo($extension)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationMultimediaUploadUrlAsyncWithHttpInfo
     *
     * Get a presigned conversation multimedia upload URL
     *
     * @param  string $extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationMultimediaUploadUrlAsyncWithHttpInfo($extension)
    {
        $returnType = '\ultracart\v2\models\ConversationMultimediaUploadUrlResponse';
        $request = $this->getConversationMultimediaUploadUrlRequest($extension);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationMultimediaUploadUrl'
     *
     * @param  string $extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationMultimediaUploadUrlRequest($extension)
    {
        // verify the required parameter 'extension' is set
        if ($extension === null || (is_array($extension) && count($extension) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $extension when calling getConversationMultimediaUploadUrl'
            );
        }

        $resourcePath = '/conversation/upload_url/{extension}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($extension !== null) {
            $resourcePath = str_replace(
                '{' . 'extension' . '}',
                ObjectSerializer::toPathValue($extension),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationPbxAudioUploadUrl
     *
     * Get a pre-signed conversation multimedia upload URL
     *
     * @param  string $extension extension (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationMultimediaUploadUrlResponse
     */
    public function getConversationPbxAudioUploadUrl($extension)
    {
        list($response) = $this->getConversationPbxAudioUploadUrlWithHttpInfo($extension);
        return $response;
    }


    /**
     * Operation getConversationPbxAudioUploadUrlWithHttpInfo
     *
     * Get a pre-signed conversation multimedia upload URL
     *
     * @param  string $extension (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationMultimediaUploadUrlResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationPbxAudioUploadUrlWithHttpInfo($extension)
    {
        return $this->getConversationPbxAudioUploadUrlWithHttpInfoRetry(true ,   $extension);
    }


    /**
     * Operation getConversationPbxAudioUploadUrlWithHttpInfoRetry
     *
     * Get a pre-signed conversation multimedia upload URL
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $extension (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationMultimediaUploadUrlResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationPbxAudioUploadUrlWithHttpInfoRetry($retry ,  $extension)
    {
        $returnType = '\ultracart\v2\models\ConversationMultimediaUploadUrlResponse';
        $request = $this->getConversationPbxAudioUploadUrlRequest($extension);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationPbxAudioUploadUrlWithHttpInfoRetry(false ,   $extension);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationMultimediaUploadUrlResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationPbxAudioUploadUrlAsync
     *
     * Get a pre-signed conversation multimedia upload URL
     *
     * @param  string $extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationPbxAudioUploadUrlAsync($extension)
    {
        return $this->getConversationPbxAudioUploadUrlAsyncWithHttpInfo($extension)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationPbxAudioUploadUrlAsyncWithHttpInfo
     *
     * Get a pre-signed conversation multimedia upload URL
     *
     * @param  string $extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationPbxAudioUploadUrlAsyncWithHttpInfo($extension)
    {
        $returnType = '\ultracart\v2\models\ConversationMultimediaUploadUrlResponse';
        $request = $this->getConversationPbxAudioUploadUrlRequest($extension);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationPbxAudioUploadUrl'
     *
     * @param  string $extension (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationPbxAudioUploadUrlRequest($extension)
    {
        // verify the required parameter 'extension' is set
        if ($extension === null || (is_array($extension) && count($extension) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $extension when calling getConversationPbxAudioUploadUrl'
            );
        }

        $resourcePath = '/conversation/pbx/audio/upload_url/{extension}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($extension !== null) {
            $resourcePath = str_replace(
                '{' . 'extension' . '}',
                ObjectSerializer::toPathValue($extension),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationPbxCustomerSnapshot
     *
     * Get orders and customer information for a phone number
     *
     * @param  \ultracart\v2\models\ConversationPbxCustomerSnapshotRequest $pbx_customer_snapshot_request Conversation pbx customer snapshot request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxCustomerSnapshotResponse
     */
    public function getConversationPbxCustomerSnapshot($pbx_customer_snapshot_request)
    {
        list($response) = $this->getConversationPbxCustomerSnapshotWithHttpInfo($pbx_customer_snapshot_request);
        return $response;
    }


    /**
     * Operation getConversationPbxCustomerSnapshotWithHttpInfo
     *
     * Get orders and customer information for a phone number
     *
     * @param  \ultracart\v2\models\ConversationPbxCustomerSnapshotRequest $pbx_customer_snapshot_request Conversation pbx customer snapshot request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxCustomerSnapshotResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationPbxCustomerSnapshotWithHttpInfo($pbx_customer_snapshot_request)
    {
        return $this->getConversationPbxCustomerSnapshotWithHttpInfoRetry(true ,   $pbx_customer_snapshot_request);
    }


    /**
     * Operation getConversationPbxCustomerSnapshotWithHttpInfoRetry
     *
     * Get orders and customer information for a phone number
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationPbxCustomerSnapshotRequest $pbx_customer_snapshot_request Conversation pbx customer snapshot request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxCustomerSnapshotResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationPbxCustomerSnapshotWithHttpInfoRetry($retry ,  $pbx_customer_snapshot_request)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxCustomerSnapshotResponse';
        $request = $this->getConversationPbxCustomerSnapshotRequest($pbx_customer_snapshot_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationPbxCustomerSnapshotWithHttpInfoRetry(false ,   $pbx_customer_snapshot_request);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxCustomerSnapshotResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationPbxCustomerSnapshotAsync
     *
     * Get orders and customer information for a phone number
     *
     * @param  \ultracart\v2\models\ConversationPbxCustomerSnapshotRequest $pbx_customer_snapshot_request Conversation pbx customer snapshot request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationPbxCustomerSnapshotAsync($pbx_customer_snapshot_request)
    {
        return $this->getConversationPbxCustomerSnapshotAsyncWithHttpInfo($pbx_customer_snapshot_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationPbxCustomerSnapshotAsyncWithHttpInfo
     *
     * Get orders and customer information for a phone number
     *
     * @param  \ultracart\v2\models\ConversationPbxCustomerSnapshotRequest $pbx_customer_snapshot_request Conversation pbx customer snapshot request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationPbxCustomerSnapshotAsyncWithHttpInfo($pbx_customer_snapshot_request)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxCustomerSnapshotResponse';
        $request = $this->getConversationPbxCustomerSnapshotRequest($pbx_customer_snapshot_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationPbxCustomerSnapshot'
     *
     * @param  \ultracart\v2\models\ConversationPbxCustomerSnapshotRequest $pbx_customer_snapshot_request Conversation pbx customer snapshot request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationPbxCustomerSnapshotRequest($pbx_customer_snapshot_request)
    {
        // verify the required parameter 'pbx_customer_snapshot_request' is set
        if ($pbx_customer_snapshot_request === null || (is_array($pbx_customer_snapshot_request) && count($pbx_customer_snapshot_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_customer_snapshot_request when calling getConversationPbxCustomerSnapshot'
            );
        }

        $resourcePath = '/conversation/pbx/customer_snapshot';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pbx_customer_snapshot_request)) {
            $_tempBody = $pbx_customer_snapshot_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationPermissions
     *
     * Retrieve conversation permissions
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPermissionsResponse
     */
    public function getConversationPermissions()
    {
        list($response) = $this->getConversationPermissionsWithHttpInfo();
        return $response;
    }


    /**
     * Operation getConversationPermissionsWithHttpInfo
     *
     * Retrieve conversation permissions
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPermissionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationPermissionsWithHttpInfo()
    {
        return $this->getConversationPermissionsWithHttpInfoRetry(true );
    }


    /**
     * Operation getConversationPermissionsWithHttpInfoRetry
     *
     * Retrieve conversation permissions
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPermissionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationPermissionsWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPermissionsResponse';
        $request = $this->getConversationPermissionsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationPermissionsWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPermissionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationPermissionsAsync
     *
     * Retrieve conversation permissions
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationPermissionsAsync()
    {
        return $this->getConversationPermissionsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationPermissionsAsyncWithHttpInfo
     *
     * Retrieve conversation permissions
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationPermissionsAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPermissionsResponse';
        $request = $this->getConversationPermissionsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationPermissions'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationPermissionsRequest()
    {

        $resourcePath = '/conversation/permissions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationWebchatQueueStatuses
     *
     * Retrieve a conversation webchat queue statuses
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationWebchatQueueStatusesResponse
     */
    public function getConversationWebchatQueueStatuses()
    {
        list($response) = $this->getConversationWebchatQueueStatusesWithHttpInfo();
        return $response;
    }


    /**
     * Operation getConversationWebchatQueueStatusesWithHttpInfo
     *
     * Retrieve a conversation webchat queue statuses
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationWebchatQueueStatusesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationWebchatQueueStatusesWithHttpInfo()
    {
        return $this->getConversationWebchatQueueStatusesWithHttpInfoRetry(true );
    }


    /**
     * Operation getConversationWebchatQueueStatusesWithHttpInfoRetry
     *
     * Retrieve a conversation webchat queue statuses
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationWebchatQueueStatusesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationWebchatQueueStatusesWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationWebchatQueueStatusesResponse';
        $request = $this->getConversationWebchatQueueStatusesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationWebchatQueueStatusesWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationWebchatQueueStatusesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationWebchatQueueStatusesAsync
     *
     * Retrieve a conversation webchat queue statuses
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationWebchatQueueStatusesAsync()
    {
        return $this->getConversationWebchatQueueStatusesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationWebchatQueueStatusesAsyncWithHttpInfo
     *
     * Retrieve a conversation webchat queue statuses
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationWebchatQueueStatusesAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationWebchatQueueStatusesResponse';
        $request = $this->getConversationWebchatQueueStatusesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationWebchatQueueStatuses'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationWebchatQueueStatusesRequest()
    {

        $resourcePath = '/conversation/conversations/queues/statuses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversations
     *
     * Retrieve a list of conversation summaries newest to oldest
     *
     * @param  string $medium medium (optional)
     * @param  string $before before (optional)
     * @param  int $_limit The maximum number of records to return on this one API call. (Max 200) (optional, default to 100)
     * @param  int $_offset Pagination of the record set.  Offset is a zero based index. (optional, default to 0)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationsResponse
     */
    public function getConversations($medium = null, $before = null, $_limit = '100', $_offset = '0')
    {
        list($response) = $this->getConversationsWithHttpInfo($medium, $before, $_limit, $_offset);
        return $response;
    }


    /**
     * Operation getConversationsWithHttpInfo
     *
     * Retrieve a list of conversation summaries newest to oldest
     *
     * @param  string $medium (optional)
     * @param  string $before (optional)
     * @param  int $_limit The maximum number of records to return on this one API call. (Max 200) (optional, default to 100)
     * @param  int $_offset Pagination of the record set.  Offset is a zero based index. (optional, default to 0)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationsWithHttpInfo($medium = null, $before = null, $_limit = '100', $_offset = '0')
    {
        return $this->getConversationsWithHttpInfoRetry(true ,   $medium,   $before,   $_limit,   $_offset);
    }


    /**
     * Operation getConversationsWithHttpInfoRetry
     *
     * Retrieve a list of conversation summaries newest to oldest
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $medium (optional)
     * @param  string $before (optional)
     * @param  int $_limit The maximum number of records to return on this one API call. (Max 200) (optional, default to 100)
     * @param  int $_offset Pagination of the record set.  Offset is a zero based index. (optional, default to 0)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationsWithHttpInfoRetry($retry ,  $medium = null,  $before = null,  $_limit = '100',  $_offset = '0')
    {
        $returnType = '\ultracart\v2\models\ConversationsResponse';
        $request = $this->getConversationsRequest($medium, $before, $_limit, $_offset);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationsWithHttpInfoRetry(false ,   $medium,   $before,   $_limit,   $_offset);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationsAsync
     *
     * Retrieve a list of conversation summaries newest to oldest
     *
     * @param  string $medium (optional)
     * @param  string $before (optional)
     * @param  int $_limit The maximum number of records to return on this one API call. (Max 200) (optional, default to 100)
     * @param  int $_offset Pagination of the record set.  Offset is a zero based index. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationsAsync($medium = null, $before = null, $_limit = '100', $_offset = '0')
    {
        return $this->getConversationsAsyncWithHttpInfo($medium, $before, $_limit, $_offset)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationsAsyncWithHttpInfo
     *
     * Retrieve a list of conversation summaries newest to oldest
     *
     * @param  string $medium (optional)
     * @param  string $before (optional)
     * @param  int $_limit The maximum number of records to return on this one API call. (Max 200) (optional, default to 100)
     * @param  int $_offset Pagination of the record set.  Offset is a zero based index. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationsAsyncWithHttpInfo($medium = null, $before = null, $_limit = '100', $_offset = '0')
    {
        $returnType = '\ultracart\v2\models\ConversationsResponse';
        $request = $this->getConversationsRequest($medium, $before, $_limit, $_offset);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversations'
     *
     * @param  string $medium (optional)
     * @param  string $before (optional)
     * @param  int $_limit The maximum number of records to return on this one API call. (Max 200) (optional, default to 100)
     * @param  int $_offset Pagination of the record set.  Offset is a zero based index. (optional, default to 0)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationsRequest($medium = null, $before = null, $_limit = '100', $_offset = '0')
    {

        $resourcePath = '/conversation/conversations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($medium !== null) {
            $queryParams['medium'] = ObjectSerializer::toQueryValue($medium);
        }
        // query params
        if ($before !== null) {
            $queryParams['before'] = ObjectSerializer::toQueryValue($before);
        }
        // query params
        if ($_limit !== null) {
            $queryParams['_limit'] = ObjectSerializer::toQueryValue($_limit);
        }
        // query params
        if ($_offset !== null) {
            $queryParams['_offset'] = ObjectSerializer::toQueryValue($_offset);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationsAutocomplete
     *
     * Retrieve a list of matching terms for a search field
     *
     * @param  \ultracart\v2\models\ConversationAutocompleteRequest $autocomplete_request Autocomplete Request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationAutocompleteResponse
     */
    public function getConversationsAutocomplete($autocomplete_request)
    {
        list($response) = $this->getConversationsAutocompleteWithHttpInfo($autocomplete_request);
        return $response;
    }


    /**
     * Operation getConversationsAutocompleteWithHttpInfo
     *
     * Retrieve a list of matching terms for a search field
     *
     * @param  \ultracart\v2\models\ConversationAutocompleteRequest $autocomplete_request Autocomplete Request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationAutocompleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationsAutocompleteWithHttpInfo($autocomplete_request)
    {
        return $this->getConversationsAutocompleteWithHttpInfoRetry(true ,   $autocomplete_request);
    }


    /**
     * Operation getConversationsAutocompleteWithHttpInfoRetry
     *
     * Retrieve a list of matching terms for a search field
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationAutocompleteRequest $autocomplete_request Autocomplete Request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationAutocompleteResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationsAutocompleteWithHttpInfoRetry($retry ,  $autocomplete_request)
    {
        $returnType = '\ultracart\v2\models\ConversationAutocompleteResponse';
        $request = $this->getConversationsAutocompleteRequest($autocomplete_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationsAutocompleteWithHttpInfoRetry(false ,   $autocomplete_request);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationAutocompleteResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationsAutocompleteAsync
     *
     * Retrieve a list of matching terms for a search field
     *
     * @param  \ultracart\v2\models\ConversationAutocompleteRequest $autocomplete_request Autocomplete Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationsAutocompleteAsync($autocomplete_request)
    {
        return $this->getConversationsAutocompleteAsyncWithHttpInfo($autocomplete_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationsAutocompleteAsyncWithHttpInfo
     *
     * Retrieve a list of matching terms for a search field
     *
     * @param  \ultracart\v2\models\ConversationAutocompleteRequest $autocomplete_request Autocomplete Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationsAutocompleteAsyncWithHttpInfo($autocomplete_request)
    {
        $returnType = '\ultracart\v2\models\ConversationAutocompleteResponse';
        $request = $this->getConversationsAutocompleteRequest($autocomplete_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationsAutocomplete'
     *
     * @param  \ultracart\v2\models\ConversationAutocompleteRequest $autocomplete_request Autocomplete Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationsAutocompleteRequest($autocomplete_request)
    {
        // verify the required parameter 'autocomplete_request' is set
        if ($autocomplete_request === null || (is_array($autocomplete_request) && count($autocomplete_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $autocomplete_request when calling getConversationsAutocomplete'
            );
        }

        $resourcePath = '/conversation/conversations/autocomplete';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($autocomplete_request)) {
            $_tempBody = $autocomplete_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getConversationsSearch
     *
     * Search conversations
     *
     * @param  \ultracart\v2\models\ConversationSearchRequest $search_request Search Request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationSearchResponse
     */
    public function getConversationsSearch($search_request)
    {
        list($response) = $this->getConversationsSearchWithHttpInfo($search_request);
        return $response;
    }


    /**
     * Operation getConversationsSearchWithHttpInfo
     *
     * Search conversations
     *
     * @param  \ultracart\v2\models\ConversationSearchRequest $search_request Search Request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationsSearchWithHttpInfo($search_request)
    {
        return $this->getConversationsSearchWithHttpInfoRetry(true ,   $search_request);
    }


    /**
     * Operation getConversationsSearchWithHttpInfoRetry
     *
     * Search conversations
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationSearchRequest $search_request Search Request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationSearchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getConversationsSearchWithHttpInfoRetry($retry ,  $search_request)
    {
        $returnType = '\ultracart\v2\models\ConversationSearchResponse';
        $request = $this->getConversationsSearchRequest($search_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getConversationsSearchWithHttpInfoRetry(false ,   $search_request);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationSearchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getConversationsSearchAsync
     *
     * Search conversations
     *
     * @param  \ultracart\v2\models\ConversationSearchRequest $search_request Search Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationsSearchAsync($search_request)
    {
        return $this->getConversationsSearchAsyncWithHttpInfo($search_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getConversationsSearchAsyncWithHttpInfo
     *
     * Search conversations
     *
     * @param  \ultracart\v2\models\ConversationSearchRequest $search_request Search Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getConversationsSearchAsyncWithHttpInfo($search_request)
    {
        $returnType = '\ultracart\v2\models\ConversationSearchResponse';
        $request = $this->getConversationsSearchRequest($search_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getConversationsSearch'
     *
     * @param  \ultracart\v2\models\ConversationSearchRequest $search_request Search Request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getConversationsSearchRequest($search_request)
    {
        // verify the required parameter 'search_request' is set
        if ($search_request === null || (is_array($search_request) && count($search_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search_request when calling getConversationsSearch'
            );
        }

        $resourcePath = '/conversation/conversations/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($search_request)) {
            $_tempBody = $search_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getLocationsForEngagement
     *
     * Get location data for engagement configuration
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationLocationsResponse
     */
    public function getLocationsForEngagement()
    {
        list($response) = $this->getLocationsForEngagementWithHttpInfo();
        return $response;
    }


    /**
     * Operation getLocationsForEngagementWithHttpInfo
     *
     * Get location data for engagement configuration
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationLocationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLocationsForEngagementWithHttpInfo()
    {
        return $this->getLocationsForEngagementWithHttpInfoRetry(true );
    }


    /**
     * Operation getLocationsForEngagementWithHttpInfoRetry
     *
     * Get location data for engagement configuration
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationLocationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getLocationsForEngagementWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationLocationsResponse';
        $request = $this->getLocationsForEngagementRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getLocationsForEngagementWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationLocationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getLocationsForEngagementAsync
     *
     * Get location data for engagement configuration
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocationsForEngagementAsync()
    {
        return $this->getLocationsForEngagementAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getLocationsForEngagementAsyncWithHttpInfo
     *
     * Get location data for engagement configuration
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getLocationsForEngagementAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationLocationsResponse';
        $request = $this->getLocationsForEngagementRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getLocationsForEngagement'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getLocationsForEngagementRequest()
    {

        $resourcePath = '/conversation/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxAgent
     *
     * Get pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid conversation_pbx_agent_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAgentResponse
     */
    public function getPbxAgent($conversation_pbx_agent_uuid)
    {
        list($response) = $this->getPbxAgentWithHttpInfo($conversation_pbx_agent_uuid);
        return $response;
    }


    /**
     * Operation getPbxAgentWithHttpInfo
     *
     * Get pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAgentWithHttpInfo($conversation_pbx_agent_uuid)
    {
        return $this->getPbxAgentWithHttpInfoRetry(true ,   $conversation_pbx_agent_uuid);
    }


    /**
     * Operation getPbxAgentWithHttpInfoRetry
     *
     * Get pbx agent
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAgentWithHttpInfoRetry($retry ,  $conversation_pbx_agent_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentResponse';
        $request = $this->getPbxAgentRequest($conversation_pbx_agent_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxAgentWithHttpInfoRetry(false ,   $conversation_pbx_agent_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAgentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxAgentAsync
     *
     * Get pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAgentAsync($conversation_pbx_agent_uuid)
    {
        return $this->getPbxAgentAsyncWithHttpInfo($conversation_pbx_agent_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxAgentAsyncWithHttpInfo
     *
     * Get pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAgentAsyncWithHttpInfo($conversation_pbx_agent_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentResponse';
        $request = $this->getPbxAgentRequest($conversation_pbx_agent_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxAgent'
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxAgentRequest($conversation_pbx_agent_uuid)
    {
        // verify the required parameter 'conversation_pbx_agent_uuid' is set
        if ($conversation_pbx_agent_uuid === null || (is_array($conversation_pbx_agent_uuid) && count($conversation_pbx_agent_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_agent_uuid when calling getPbxAgent'
            );
        }

        $resourcePath = '/conversation/pbx/agent/{conversationPbxAgentUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_agent_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxAgentUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_agent_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxAgentVoicemail
     *
     * Get Agent Voicemail
     *
     * @param  string $recording_sid recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxVoicemailMessageResponse
     */
    public function getPbxAgentVoicemail($recording_sid)
    {
        list($response) = $this->getPbxAgentVoicemailWithHttpInfo($recording_sid);
        return $response;
    }


    /**
     * Operation getPbxAgentVoicemailWithHttpInfo
     *
     * Get Agent Voicemail
     *
     * @param  string $recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAgentVoicemailWithHttpInfo($recording_sid)
    {
        return $this->getPbxAgentVoicemailWithHttpInfoRetry(true ,   $recording_sid);
    }


    /**
     * Operation getPbxAgentVoicemailWithHttpInfoRetry
     *
     * Get Agent Voicemail
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAgentVoicemailWithHttpInfoRetry($retry ,  $recording_sid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMessageResponse';
        $request = $this->getPbxAgentVoicemailRequest($recording_sid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxAgentVoicemailWithHttpInfoRetry(false ,   $recording_sid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxVoicemailMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxAgentVoicemailAsync
     *
     * Get Agent Voicemail
     *
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAgentVoicemailAsync($recording_sid)
    {
        return $this->getPbxAgentVoicemailAsyncWithHttpInfo($recording_sid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxAgentVoicemailAsyncWithHttpInfo
     *
     * Get Agent Voicemail
     *
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAgentVoicemailAsyncWithHttpInfo($recording_sid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMessageResponse';
        $request = $this->getPbxAgentVoicemailRequest($recording_sid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxAgentVoicemail'
     *
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxAgentVoicemailRequest($recording_sid)
    {
        // verify the required parameter 'recording_sid' is set
        if ($recording_sid === null || (is_array($recording_sid) && count($recording_sid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_sid when calling getPbxAgentVoicemail'
            );
        }

        $resourcePath = '/conversation/pbx/agent/voicemails/{recording_sid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($recording_sid !== null) {
            $resourcePath = str_replace(
                '{' . 'recording_sid' . '}',
                ObjectSerializer::toPathValue($recording_sid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxAgentVoicemails
     *
     * Get Agent Voicemails
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse
     */
    public function getPbxAgentVoicemails()
    {
        list($response) = $this->getPbxAgentVoicemailsWithHttpInfo();
        return $response;
    }


    /**
     * Operation getPbxAgentVoicemailsWithHttpInfo
     *
     * Get Agent Voicemails
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAgentVoicemailsWithHttpInfo()
    {
        return $this->getPbxAgentVoicemailsWithHttpInfoRetry(true );
    }


    /**
     * Operation getPbxAgentVoicemailsWithHttpInfoRetry
     *
     * Get Agent Voicemails
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAgentVoicemailsWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse';
        $request = $this->getPbxAgentVoicemailsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxAgentVoicemailsWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxAgentVoicemailsAsync
     *
     * Get Agent Voicemails
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAgentVoicemailsAsync()
    {
        return $this->getPbxAgentVoicemailsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxAgentVoicemailsAsyncWithHttpInfo
     *
     * Get Agent Voicemails
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAgentVoicemailsAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse';
        $request = $this->getPbxAgentVoicemailsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxAgentVoicemails'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxAgentVoicemailsRequest()
    {

        $resourcePath = '/conversation/pbx/agent/voicemails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxAgents
     *
     * Get pbx agents
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAgentsResponse
     */
    public function getPbxAgents()
    {
        list($response) = $this->getPbxAgentsWithHttpInfo();
        return $response;
    }


    /**
     * Operation getPbxAgentsWithHttpInfo
     *
     * Get pbx agents
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAgentsWithHttpInfo()
    {
        return $this->getPbxAgentsWithHttpInfoRetry(true );
    }


    /**
     * Operation getPbxAgentsWithHttpInfoRetry
     *
     * Get pbx agents
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAgentsWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentsResponse';
        $request = $this->getPbxAgentsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxAgentsWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAgentsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxAgentsAsync
     *
     * Get pbx agents
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAgentsAsync()
    {
        return $this->getPbxAgentsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxAgentsAsyncWithHttpInfo
     *
     * Get pbx agents
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAgentsAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentsResponse';
        $request = $this->getPbxAgentsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxAgents'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxAgentsRequest()
    {

        $resourcePath = '/conversation/pbx/agent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxAudio
     *
     * Get pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid conversation_pbx_audio_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAudioResponse
     */
    public function getPbxAudio($conversation_pbx_audio_uuid)
    {
        list($response) = $this->getPbxAudioWithHttpInfo($conversation_pbx_audio_uuid);
        return $response;
    }


    /**
     * Operation getPbxAudioWithHttpInfo
     *
     * Get pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudioResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAudioWithHttpInfo($conversation_pbx_audio_uuid)
    {
        return $this->getPbxAudioWithHttpInfoRetry(true ,   $conversation_pbx_audio_uuid);
    }


    /**
     * Operation getPbxAudioWithHttpInfoRetry
     *
     * Get pbx audio
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudioResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAudioWithHttpInfoRetry($retry ,  $conversation_pbx_audio_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudioResponse';
        $request = $this->getPbxAudioRequest($conversation_pbx_audio_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxAudioWithHttpInfoRetry(false ,   $conversation_pbx_audio_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAudioResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxAudioAsync
     *
     * Get pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAudioAsync($conversation_pbx_audio_uuid)
    {
        return $this->getPbxAudioAsyncWithHttpInfo($conversation_pbx_audio_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxAudioAsyncWithHttpInfo
     *
     * Get pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAudioAsyncWithHttpInfo($conversation_pbx_audio_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudioResponse';
        $request = $this->getPbxAudioRequest($conversation_pbx_audio_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxAudio'
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxAudioRequest($conversation_pbx_audio_uuid)
    {
        // verify the required parameter 'conversation_pbx_audio_uuid' is set
        if ($conversation_pbx_audio_uuid === null || (is_array($conversation_pbx_audio_uuid) && count($conversation_pbx_audio_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_audio_uuid when calling getPbxAudio'
            );
        }

        $resourcePath = '/conversation/pbx/audio/{conversationPbxAudioUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_audio_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxAudioUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_audio_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxAudios
     *
     * Get pbx audios
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAudiosResponse
     */
    public function getPbxAudios()
    {
        list($response) = $this->getPbxAudiosWithHttpInfo();
        return $response;
    }


    /**
     * Operation getPbxAudiosWithHttpInfo
     *
     * Get pbx audios
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudiosResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAudiosWithHttpInfo()
    {
        return $this->getPbxAudiosWithHttpInfoRetry(true );
    }


    /**
     * Operation getPbxAudiosWithHttpInfoRetry
     *
     * Get pbx audios
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudiosResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxAudiosWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudiosResponse';
        $request = $this->getPbxAudiosRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxAudiosWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAudiosResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxAudiosAsync
     *
     * Get pbx audios
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAudiosAsync()
    {
        return $this->getPbxAudiosAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxAudiosAsyncWithHttpInfo
     *
     * Get pbx audios
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxAudiosAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudiosResponse';
        $request = $this->getPbxAudiosRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxAudios'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxAudiosRequest()
    {

        $resourcePath = '/conversation/pbx/audio';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxMenu
     *
     * Get pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid conversation_pbx_menu_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxMenuResponse
     */
    public function getPbxMenu($conversation_pbx_menu_uuid)
    {
        list($response) = $this->getPbxMenuWithHttpInfo($conversation_pbx_menu_uuid);
        return $response;
    }


    /**
     * Operation getPbxMenuWithHttpInfo
     *
     * Get pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxMenuWithHttpInfo($conversation_pbx_menu_uuid)
    {
        return $this->getPbxMenuWithHttpInfoRetry(true ,   $conversation_pbx_menu_uuid);
    }


    /**
     * Operation getPbxMenuWithHttpInfoRetry
     *
     * Get pbx menu
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxMenuWithHttpInfoRetry($retry ,  $conversation_pbx_menu_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenuResponse';
        $request = $this->getPbxMenuRequest($conversation_pbx_menu_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxMenuWithHttpInfoRetry(false ,   $conversation_pbx_menu_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxMenuResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxMenuAsync
     *
     * Get pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxMenuAsync($conversation_pbx_menu_uuid)
    {
        return $this->getPbxMenuAsyncWithHttpInfo($conversation_pbx_menu_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxMenuAsyncWithHttpInfo
     *
     * Get pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxMenuAsyncWithHttpInfo($conversation_pbx_menu_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenuResponse';
        $request = $this->getPbxMenuRequest($conversation_pbx_menu_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxMenu'
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxMenuRequest($conversation_pbx_menu_uuid)
    {
        // verify the required parameter 'conversation_pbx_menu_uuid' is set
        if ($conversation_pbx_menu_uuid === null || (is_array($conversation_pbx_menu_uuid) && count($conversation_pbx_menu_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_menu_uuid when calling getPbxMenu'
            );
        }

        $resourcePath = '/conversation/pbx/menu/{conversationPbxMenuUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_menu_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxMenuUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_menu_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxMenus
     *
     * Get pbx menus
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxMenusResponse
     */
    public function getPbxMenus()
    {
        list($response) = $this->getPbxMenusWithHttpInfo();
        return $response;
    }


    /**
     * Operation getPbxMenusWithHttpInfo
     *
     * Get pbx menus
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenusResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxMenusWithHttpInfo()
    {
        return $this->getPbxMenusWithHttpInfoRetry(true );
    }


    /**
     * Operation getPbxMenusWithHttpInfoRetry
     *
     * Get pbx menus
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenusResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxMenusWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenusResponse';
        $request = $this->getPbxMenusRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxMenusWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxMenusResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxMenusAsync
     *
     * Get pbx menus
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxMenusAsync()
    {
        return $this->getPbxMenusAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxMenusAsyncWithHttpInfo
     *
     * Get pbx menus
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxMenusAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenusResponse';
        $request = $this->getPbxMenusRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxMenus'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxMenusRequest()
    {

        $resourcePath = '/conversation/pbx/menu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxPhoneNumber
     *
     * Get pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid conversation_pbx_phone_number_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxPhoneNumberResponse
     */
    public function getPbxPhoneNumber($conversation_pbx_phone_number_uuid)
    {
        list($response) = $this->getPbxPhoneNumberWithHttpInfo($conversation_pbx_phone_number_uuid);
        return $response;
    }


    /**
     * Operation getPbxPhoneNumberWithHttpInfo
     *
     * Get pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxPhoneNumberWithHttpInfo($conversation_pbx_phone_number_uuid)
    {
        return $this->getPbxPhoneNumberWithHttpInfoRetry(true ,   $conversation_pbx_phone_number_uuid);
    }


    /**
     * Operation getPbxPhoneNumberWithHttpInfoRetry
     *
     * Get pbx phoneNumber
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxPhoneNumberWithHttpInfoRetry($retry ,  $conversation_pbx_phone_number_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumberResponse';
        $request = $this->getPbxPhoneNumberRequest($conversation_pbx_phone_number_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxPhoneNumberWithHttpInfoRetry(false ,   $conversation_pbx_phone_number_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxPhoneNumberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxPhoneNumberAsync
     *
     * Get pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxPhoneNumberAsync($conversation_pbx_phone_number_uuid)
    {
        return $this->getPbxPhoneNumberAsyncWithHttpInfo($conversation_pbx_phone_number_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxPhoneNumberAsyncWithHttpInfo
     *
     * Get pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxPhoneNumberAsyncWithHttpInfo($conversation_pbx_phone_number_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumberResponse';
        $request = $this->getPbxPhoneNumberRequest($conversation_pbx_phone_number_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxPhoneNumber'
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxPhoneNumberRequest($conversation_pbx_phone_number_uuid)
    {
        // verify the required parameter 'conversation_pbx_phone_number_uuid' is set
        if ($conversation_pbx_phone_number_uuid === null || (is_array($conversation_pbx_phone_number_uuid) && count($conversation_pbx_phone_number_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_phone_number_uuid when calling getPbxPhoneNumber'
            );
        }

        $resourcePath = '/conversation/pbx/phone_number/{conversationPbxPhoneNumberUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_phone_number_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxPhoneNumberUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_phone_number_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxPhoneNumbers
     *
     * Get pbx phoneNumbers
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxPhoneNumbersResponse
     */
    public function getPbxPhoneNumbers()
    {
        list($response) = $this->getPbxPhoneNumbersWithHttpInfo();
        return $response;
    }


    /**
     * Operation getPbxPhoneNumbersWithHttpInfo
     *
     * Get pbx phoneNumbers
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumbersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxPhoneNumbersWithHttpInfo()
    {
        return $this->getPbxPhoneNumbersWithHttpInfoRetry(true );
    }


    /**
     * Operation getPbxPhoneNumbersWithHttpInfoRetry
     *
     * Get pbx phoneNumbers
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumbersResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxPhoneNumbersWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumbersResponse';
        $request = $this->getPbxPhoneNumbersRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxPhoneNumbersWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxPhoneNumbersResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxPhoneNumbersAsync
     *
     * Get pbx phoneNumbers
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxPhoneNumbersAsync()
    {
        return $this->getPbxPhoneNumbersAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxPhoneNumbersAsyncWithHttpInfo
     *
     * Get pbx phoneNumbers
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxPhoneNumbersAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumbersResponse';
        $request = $this->getPbxPhoneNumbersRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxPhoneNumbers'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxPhoneNumbersRequest()
    {

        $resourcePath = '/conversation/pbx/phone_number';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxQueue
     *
     * Get pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid conversation_pbx_queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxQueueResponse
     */
    public function getPbxQueue($conversation_pbx_queue_uuid)
    {
        list($response) = $this->getPbxQueueWithHttpInfo($conversation_pbx_queue_uuid);
        return $response;
    }


    /**
     * Operation getPbxQueueWithHttpInfo
     *
     * Get pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueueResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxQueueWithHttpInfo($conversation_pbx_queue_uuid)
    {
        return $this->getPbxQueueWithHttpInfoRetry(true ,   $conversation_pbx_queue_uuid);
    }


    /**
     * Operation getPbxQueueWithHttpInfoRetry
     *
     * Get pbx queue
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueueResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxQueueWithHttpInfoRetry($retry ,  $conversation_pbx_queue_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueueResponse';
        $request = $this->getPbxQueueRequest($conversation_pbx_queue_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxQueueWithHttpInfoRetry(false ,   $conversation_pbx_queue_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxQueueResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxQueueAsync
     *
     * Get pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxQueueAsync($conversation_pbx_queue_uuid)
    {
        return $this->getPbxQueueAsyncWithHttpInfo($conversation_pbx_queue_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxQueueAsyncWithHttpInfo
     *
     * Get pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxQueueAsyncWithHttpInfo($conversation_pbx_queue_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueueResponse';
        $request = $this->getPbxQueueRequest($conversation_pbx_queue_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxQueue'
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxQueueRequest($conversation_pbx_queue_uuid)
    {
        // verify the required parameter 'conversation_pbx_queue_uuid' is set
        if ($conversation_pbx_queue_uuid === null || (is_array($conversation_pbx_queue_uuid) && count($conversation_pbx_queue_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_queue_uuid when calling getPbxQueue'
            );
        }

        $resourcePath = '/conversation/pbx/queue/{conversationPbxQueueUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_queue_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxQueueUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_queue_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxQueueVoicemail
     *
     * Get Queue Voicemail
     *
     * @param  string $queue_uuid queue_uuid (required)
     * @param  string $recording_sid recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxVoicemailMessageResponse
     */
    public function getPbxQueueVoicemail($queue_uuid, $recording_sid)
    {
        list($response) = $this->getPbxQueueVoicemailWithHttpInfo($queue_uuid, $recording_sid);
        return $response;
    }


    /**
     * Operation getPbxQueueVoicemailWithHttpInfo
     *
     * Get Queue Voicemail
     *
     * @param  string $queue_uuid (required)
     * @param  string $recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxQueueVoicemailWithHttpInfo($queue_uuid, $recording_sid)
    {
        return $this->getPbxQueueVoicemailWithHttpInfoRetry(true ,   $queue_uuid,   $recording_sid);
    }


    /**
     * Operation getPbxQueueVoicemailWithHttpInfoRetry
     *
     * Get Queue Voicemail
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $queue_uuid (required)
     * @param  string $recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxQueueVoicemailWithHttpInfoRetry($retry ,  $queue_uuid,  $recording_sid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMessageResponse';
        $request = $this->getPbxQueueVoicemailRequest($queue_uuid, $recording_sid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxQueueVoicemailWithHttpInfoRetry(false ,   $queue_uuid,   $recording_sid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxVoicemailMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxQueueVoicemailAsync
     *
     * Get Queue Voicemail
     *
     * @param  string $queue_uuid (required)
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxQueueVoicemailAsync($queue_uuid, $recording_sid)
    {
        return $this->getPbxQueueVoicemailAsyncWithHttpInfo($queue_uuid, $recording_sid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxQueueVoicemailAsyncWithHttpInfo
     *
     * Get Queue Voicemail
     *
     * @param  string $queue_uuid (required)
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxQueueVoicemailAsyncWithHttpInfo($queue_uuid, $recording_sid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMessageResponse';
        $request = $this->getPbxQueueVoicemailRequest($queue_uuid, $recording_sid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxQueueVoicemail'
     *
     * @param  string $queue_uuid (required)
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxQueueVoicemailRequest($queue_uuid, $recording_sid)
    {
        // verify the required parameter 'queue_uuid' is set
        if ($queue_uuid === null || (is_array($queue_uuid) && count($queue_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_uuid when calling getPbxQueueVoicemail'
            );
        }
        // verify the required parameter 'recording_sid' is set
        if ($recording_sid === null || (is_array($recording_sid) && count($recording_sid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_sid when calling getPbxQueueVoicemail'
            );
        }

        $resourcePath = '/conversation/pbx/queues/{queue_uuid}/voicemails/{recording_sid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($queue_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'queue_uuid' . '}',
                ObjectSerializer::toPathValue($queue_uuid),
                $resourcePath
            );
        }
        // path params
        if ($recording_sid !== null) {
            $resourcePath = str_replace(
                '{' . 'recording_sid' . '}',
                ObjectSerializer::toPathValue($recording_sid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxQueueVoicemails
     *
     * Get Queue Voicemails
     *
     * @param  string $queue_uuid queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse
     */
    public function getPbxQueueVoicemails($queue_uuid)
    {
        list($response) = $this->getPbxQueueVoicemailsWithHttpInfo($queue_uuid);
        return $response;
    }


    /**
     * Operation getPbxQueueVoicemailsWithHttpInfo
     *
     * Get Queue Voicemails
     *
     * @param  string $queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxQueueVoicemailsWithHttpInfo($queue_uuid)
    {
        return $this->getPbxQueueVoicemailsWithHttpInfoRetry(true ,   $queue_uuid);
    }


    /**
     * Operation getPbxQueueVoicemailsWithHttpInfoRetry
     *
     * Get Queue Voicemails
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxQueueVoicemailsWithHttpInfoRetry($retry ,  $queue_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse';
        $request = $this->getPbxQueueVoicemailsRequest($queue_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxQueueVoicemailsWithHttpInfoRetry(false ,   $queue_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxQueueVoicemailsAsync
     *
     * Get Queue Voicemails
     *
     * @param  string $queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxQueueVoicemailsAsync($queue_uuid)
    {
        return $this->getPbxQueueVoicemailsAsyncWithHttpInfo($queue_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxQueueVoicemailsAsyncWithHttpInfo
     *
     * Get Queue Voicemails
     *
     * @param  string $queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxQueueVoicemailsAsyncWithHttpInfo($queue_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMessageSummariesResponse';
        $request = $this->getPbxQueueVoicemailsRequest($queue_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxQueueVoicemails'
     *
     * @param  string $queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxQueueVoicemailsRequest($queue_uuid)
    {
        // verify the required parameter 'queue_uuid' is set
        if ($queue_uuid === null || (is_array($queue_uuid) && count($queue_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_uuid when calling getPbxQueueVoicemails'
            );
        }

        $resourcePath = '/conversation/pbx/queues/{queue_uuid}/voicemails';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($queue_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'queue_uuid' . '}',
                ObjectSerializer::toPathValue($queue_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxQueues
     *
     * Get pbx queues
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxQueuesResponse
     */
    public function getPbxQueues()
    {
        list($response) = $this->getPbxQueuesWithHttpInfo();
        return $response;
    }


    /**
     * Operation getPbxQueuesWithHttpInfo
     *
     * Get pbx queues
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueuesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxQueuesWithHttpInfo()
    {
        return $this->getPbxQueuesWithHttpInfoRetry(true );
    }


    /**
     * Operation getPbxQueuesWithHttpInfoRetry
     *
     * Get pbx queues
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueuesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxQueuesWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueuesResponse';
        $request = $this->getPbxQueuesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxQueuesWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxQueuesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxQueuesAsync
     *
     * Get pbx queues
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxQueuesAsync()
    {
        return $this->getPbxQueuesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxQueuesAsyncWithHttpInfo
     *
     * Get pbx queues
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxQueuesAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueuesResponse';
        $request = $this->getPbxQueuesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxQueues'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxQueuesRequest()
    {

        $resourcePath = '/conversation/pbx/queue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxTimeBased
     *
     * Get pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid conversation_pbx_time_based_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeBasedResponse
     */
    public function getPbxTimeBased($conversation_pbx_time_based_uuid)
    {
        list($response) = $this->getPbxTimeBasedWithHttpInfo($conversation_pbx_time_based_uuid);
        return $response;
    }


    /**
     * Operation getPbxTimeBasedWithHttpInfo
     *
     * Get pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxTimeBasedWithHttpInfo($conversation_pbx_time_based_uuid)
    {
        return $this->getPbxTimeBasedWithHttpInfoRetry(true ,   $conversation_pbx_time_based_uuid);
    }


    /**
     * Operation getPbxTimeBasedWithHttpInfoRetry
     *
     * Get pbx timeBased
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxTimeBasedWithHttpInfoRetry($retry ,  $conversation_pbx_time_based_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedResponse';
        $request = $this->getPbxTimeBasedRequest($conversation_pbx_time_based_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxTimeBasedWithHttpInfoRetry(false ,   $conversation_pbx_time_based_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeBasedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxTimeBasedAsync
     *
     * Get pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxTimeBasedAsync($conversation_pbx_time_based_uuid)
    {
        return $this->getPbxTimeBasedAsyncWithHttpInfo($conversation_pbx_time_based_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxTimeBasedAsyncWithHttpInfo
     *
     * Get pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxTimeBasedAsyncWithHttpInfo($conversation_pbx_time_based_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedResponse';
        $request = $this->getPbxTimeBasedRequest($conversation_pbx_time_based_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxTimeBased'
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxTimeBasedRequest($conversation_pbx_time_based_uuid)
    {
        // verify the required parameter 'conversation_pbx_time_based_uuid' is set
        if ($conversation_pbx_time_based_uuid === null || (is_array($conversation_pbx_time_based_uuid) && count($conversation_pbx_time_based_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_time_based_uuid when calling getPbxTimeBased'
            );
        }

        $resourcePath = '/conversation/pbx/time_based/{conversationPbxTimeBasedUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_time_based_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxTimeBasedUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_time_based_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxTimeBaseds
     *
     * Get pbx timeBaseds
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeBasedsResponse
     */
    public function getPbxTimeBaseds()
    {
        list($response) = $this->getPbxTimeBasedsWithHttpInfo();
        return $response;
    }


    /**
     * Operation getPbxTimeBasedsWithHttpInfo
     *
     * Get pbx timeBaseds
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxTimeBasedsWithHttpInfo()
    {
        return $this->getPbxTimeBasedsWithHttpInfoRetry(true );
    }


    /**
     * Operation getPbxTimeBasedsWithHttpInfoRetry
     *
     * Get pbx timeBaseds
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxTimeBasedsWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedsResponse';
        $request = $this->getPbxTimeBasedsRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxTimeBasedsWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeBasedsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxTimeBasedsAsync
     *
     * Get pbx timeBaseds
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxTimeBasedsAsync()
    {
        return $this->getPbxTimeBasedsAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxTimeBasedsAsyncWithHttpInfo
     *
     * Get pbx timeBaseds
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxTimeBasedsAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedsResponse';
        $request = $this->getPbxTimeBasedsRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxTimeBaseds'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxTimeBasedsRequest()
    {

        $resourcePath = '/conversation/pbx/time_based';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxTimeRange
     *
     * Get pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid conversation_pbx_time_range_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeRangeResponse
     */
    public function getPbxTimeRange($conversation_pbx_time_range_uuid)
    {
        list($response) = $this->getPbxTimeRangeWithHttpInfo($conversation_pbx_time_range_uuid);
        return $response;
    }


    /**
     * Operation getPbxTimeRangeWithHttpInfo
     *
     * Get pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxTimeRangeWithHttpInfo($conversation_pbx_time_range_uuid)
    {
        return $this->getPbxTimeRangeWithHttpInfoRetry(true ,   $conversation_pbx_time_range_uuid);
    }


    /**
     * Operation getPbxTimeRangeWithHttpInfoRetry
     *
     * Get pbx timeRange
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxTimeRangeWithHttpInfoRetry($retry ,  $conversation_pbx_time_range_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangeResponse';
        $request = $this->getPbxTimeRangeRequest($conversation_pbx_time_range_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxTimeRangeWithHttpInfoRetry(false ,   $conversation_pbx_time_range_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeRangeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxTimeRangeAsync
     *
     * Get pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxTimeRangeAsync($conversation_pbx_time_range_uuid)
    {
        return $this->getPbxTimeRangeAsyncWithHttpInfo($conversation_pbx_time_range_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxTimeRangeAsyncWithHttpInfo
     *
     * Get pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxTimeRangeAsyncWithHttpInfo($conversation_pbx_time_range_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangeResponse';
        $request = $this->getPbxTimeRangeRequest($conversation_pbx_time_range_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxTimeRange'
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxTimeRangeRequest($conversation_pbx_time_range_uuid)
    {
        // verify the required parameter 'conversation_pbx_time_range_uuid' is set
        if ($conversation_pbx_time_range_uuid === null || (is_array($conversation_pbx_time_range_uuid) && count($conversation_pbx_time_range_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_time_range_uuid when calling getPbxTimeRange'
            );
        }

        $resourcePath = '/conversation/pbx/time_range/{conversationPbxTimeRangeUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_time_range_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxTimeRangeUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_time_range_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxTimeRanges
     *
     * Get pbx timeRanges
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeRangesResponse
     */
    public function getPbxTimeRanges()
    {
        list($response) = $this->getPbxTimeRangesWithHttpInfo();
        return $response;
    }


    /**
     * Operation getPbxTimeRangesWithHttpInfo
     *
     * Get pbx timeRanges
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxTimeRangesWithHttpInfo()
    {
        return $this->getPbxTimeRangesWithHttpInfoRetry(true );
    }


    /**
     * Operation getPbxTimeRangesWithHttpInfoRetry
     *
     * Get pbx timeRanges
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxTimeRangesWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangesResponse';
        $request = $this->getPbxTimeRangesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxTimeRangesWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeRangesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxTimeRangesAsync
     *
     * Get pbx timeRanges
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxTimeRangesAsync()
    {
        return $this->getPbxTimeRangesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxTimeRangesAsyncWithHttpInfo
     *
     * Get pbx timeRanges
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxTimeRangesAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangesResponse';
        $request = $this->getPbxTimeRangesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxTimeRanges'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxTimeRangesRequest()
    {

        $resourcePath = '/conversation/pbx/time_range';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxVoicemailMailbox
     *
     * Get pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse
     */
    public function getPbxVoicemailMailbox($conversation_pbx_voicemail_mailbox_uuid)
    {
        list($response) = $this->getPbxVoicemailMailboxWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid);
        return $response;
    }


    /**
     * Operation getPbxVoicemailMailboxWithHttpInfo
     *
     * Get pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxVoicemailMailboxWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid)
    {
        return $this->getPbxVoicemailMailboxWithHttpInfoRetry(true ,   $conversation_pbx_voicemail_mailbox_uuid);
    }


    /**
     * Operation getPbxVoicemailMailboxWithHttpInfoRetry
     *
     * Get pbx voicemailMailbox
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxVoicemailMailboxWithHttpInfoRetry($retry ,  $conversation_pbx_voicemail_mailbox_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse';
        $request = $this->getPbxVoicemailMailboxRequest($conversation_pbx_voicemail_mailbox_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxVoicemailMailboxWithHttpInfoRetry(false ,   $conversation_pbx_voicemail_mailbox_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxVoicemailMailboxAsync
     *
     * Get pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxVoicemailMailboxAsync($conversation_pbx_voicemail_mailbox_uuid)
    {
        return $this->getPbxVoicemailMailboxAsyncWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxVoicemailMailboxAsyncWithHttpInfo
     *
     * Get pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxVoicemailMailboxAsyncWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse';
        $request = $this->getPbxVoicemailMailboxRequest($conversation_pbx_voicemail_mailbox_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxVoicemailMailbox'
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxVoicemailMailboxRequest($conversation_pbx_voicemail_mailbox_uuid)
    {
        // verify the required parameter 'conversation_pbx_voicemail_mailbox_uuid' is set
        if ($conversation_pbx_voicemail_mailbox_uuid === null || (is_array($conversation_pbx_voicemail_mailbox_uuid) && count($conversation_pbx_voicemail_mailbox_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_voicemail_mailbox_uuid when calling getPbxVoicemailMailbox'
            );
        }

        $resourcePath = '/conversation/pbx/voicemail_mailbox/{conversationPbxVoicemailMailboxUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_voicemail_mailbox_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxVoicemailMailboxUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_voicemail_mailbox_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getPbxVoicemailMailboxes
     *
     * Get pbx voicemailMailboxes
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxVoicemailMailboxesResponse
     */
    public function getPbxVoicemailMailboxes()
    {
        list($response) = $this->getPbxVoicemailMailboxesWithHttpInfo();
        return $response;
    }


    /**
     * Operation getPbxVoicemailMailboxesWithHttpInfo
     *
     * Get pbx voicemailMailboxes
     *
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxVoicemailMailboxesWithHttpInfo()
    {
        return $this->getPbxVoicemailMailboxesWithHttpInfoRetry(true );
    }


    /**
     * Operation getPbxVoicemailMailboxesWithHttpInfoRetry
     *
     * Get pbx voicemailMailboxes
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPbxVoicemailMailboxesWithHttpInfoRetry($retry )
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxesResponse';
        $request = $this->getPbxVoicemailMailboxesRequest();

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->getPbxVoicemailMailboxesWithHttpInfoRetry(false );
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxVoicemailMailboxesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation getPbxVoicemailMailboxesAsync
     *
     * Get pbx voicemailMailboxes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxVoicemailMailboxesAsync()
    {
        return $this->getPbxVoicemailMailboxesAsyncWithHttpInfo()
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getPbxVoicemailMailboxesAsyncWithHttpInfo
     *
     * Get pbx voicemailMailboxes
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getPbxVoicemailMailboxesAsyncWithHttpInfo()
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxesResponse';
        $request = $this->getPbxVoicemailMailboxesRequest();

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getPbxVoicemailMailboxes'
     *
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function getPbxVoicemailMailboxesRequest()
    {

        $resourcePath = '/conversation/pbx/voicemail_mailbox';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertConversationCannedMessage
     *
     * Insert a canned message
     *
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationCannedMessageResponse
     */
    public function insertConversationCannedMessage($canned_message)
    {
        list($response) = $this->insertConversationCannedMessageWithHttpInfo($canned_message);
        return $response;
    }


    /**
     * Operation insertConversationCannedMessageWithHttpInfo
     *
     * Insert a canned message
     *
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationCannedMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertConversationCannedMessageWithHttpInfo($canned_message)
    {
        return $this->insertConversationCannedMessageWithHttpInfoRetry(true ,   $canned_message);
    }


    /**
     * Operation insertConversationCannedMessageWithHttpInfoRetry
     *
     * Insert a canned message
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationCannedMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertConversationCannedMessageWithHttpInfoRetry($retry ,  $canned_message)
    {
        $returnType = '\ultracart\v2\models\ConversationCannedMessageResponse';
        $request = $this->insertConversationCannedMessageRequest($canned_message);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertConversationCannedMessageWithHttpInfoRetry(false ,   $canned_message);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationCannedMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertConversationCannedMessageAsync
     *
     * Insert a canned message
     *
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertConversationCannedMessageAsync($canned_message)
    {
        return $this->insertConversationCannedMessageAsyncWithHttpInfo($canned_message)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertConversationCannedMessageAsyncWithHttpInfo
     *
     * Insert a canned message
     *
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertConversationCannedMessageAsyncWithHttpInfo($canned_message)
    {
        $returnType = '\ultracart\v2\models\ConversationCannedMessageResponse';
        $request = $this->insertConversationCannedMessageRequest($canned_message);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertConversationCannedMessage'
     *
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertConversationCannedMessageRequest($canned_message)
    {
        // verify the required parameter 'canned_message' is set
        if ($canned_message === null || (is_array($canned_message) && count($canned_message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $canned_message when calling insertConversationCannedMessage'
            );
        }

        $resourcePath = '/conversation/canned_messages';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($canned_message)) {
            $_tempBody = $canned_message;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertConversationDepartment
     *
     * Insert a department
     *
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationDepartmentResponse
     */
    public function insertConversationDepartment($department)
    {
        list($response) = $this->insertConversationDepartmentWithHttpInfo($department);
        return $response;
    }


    /**
     * Operation insertConversationDepartmentWithHttpInfo
     *
     * Insert a department
     *
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationDepartmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertConversationDepartmentWithHttpInfo($department)
    {
        return $this->insertConversationDepartmentWithHttpInfoRetry(true ,   $department);
    }


    /**
     * Operation insertConversationDepartmentWithHttpInfoRetry
     *
     * Insert a department
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationDepartmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertConversationDepartmentWithHttpInfoRetry($retry ,  $department)
    {
        $returnType = '\ultracart\v2\models\ConversationDepartmentResponse';
        $request = $this->insertConversationDepartmentRequest($department);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertConversationDepartmentWithHttpInfoRetry(false ,   $department);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationDepartmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertConversationDepartmentAsync
     *
     * Insert a department
     *
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertConversationDepartmentAsync($department)
    {
        return $this->insertConversationDepartmentAsyncWithHttpInfo($department)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertConversationDepartmentAsyncWithHttpInfo
     *
     * Insert a department
     *
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertConversationDepartmentAsyncWithHttpInfo($department)
    {
        $returnType = '\ultracart\v2\models\ConversationDepartmentResponse';
        $request = $this->insertConversationDepartmentRequest($department);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertConversationDepartment'
     *
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertConversationDepartmentRequest($department)
    {
        // verify the required parameter 'department' is set
        if ($department === null || (is_array($department) && count($department) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $department when calling insertConversationDepartment'
            );
        }

        $resourcePath = '/conversation/departments';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($department)) {
            $_tempBody = $department;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertConversationEngagement
     *
     * Insert a engagement
     *
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationEngagementResponse
     */
    public function insertConversationEngagement($engagement)
    {
        list($response) = $this->insertConversationEngagementWithHttpInfo($engagement);
        return $response;
    }


    /**
     * Operation insertConversationEngagementWithHttpInfo
     *
     * Insert a engagement
     *
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationEngagementResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertConversationEngagementWithHttpInfo($engagement)
    {
        return $this->insertConversationEngagementWithHttpInfoRetry(true ,   $engagement);
    }


    /**
     * Operation insertConversationEngagementWithHttpInfoRetry
     *
     * Insert a engagement
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationEngagementResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertConversationEngagementWithHttpInfoRetry($retry ,  $engagement)
    {
        $returnType = '\ultracart\v2\models\ConversationEngagementResponse';
        $request = $this->insertConversationEngagementRequest($engagement);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertConversationEngagementWithHttpInfoRetry(false ,   $engagement);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationEngagementResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertConversationEngagementAsync
     *
     * Insert a engagement
     *
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertConversationEngagementAsync($engagement)
    {
        return $this->insertConversationEngagementAsyncWithHttpInfo($engagement)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertConversationEngagementAsyncWithHttpInfo
     *
     * Insert a engagement
     *
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertConversationEngagementAsyncWithHttpInfo($engagement)
    {
        $returnType = '\ultracart\v2\models\ConversationEngagementResponse';
        $request = $this->insertConversationEngagementRequest($engagement);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertConversationEngagement'
     *
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertConversationEngagementRequest($engagement)
    {
        // verify the required parameter 'engagement' is set
        if ($engagement === null || (is_array($engagement) && count($engagement) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engagement when calling insertConversationEngagement'
            );
        }

        $resourcePath = '/conversation/engagements';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($engagement)) {
            $_tempBody = $engagement;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertPbxAgent
     *
     * Insert pbx agent
     *
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAgentResponse
     */
    public function insertPbxAgent($pbx_agent)
    {
        list($response) = $this->insertPbxAgentWithHttpInfo($pbx_agent);
        return $response;
    }


    /**
     * Operation insertPbxAgentWithHttpInfo
     *
     * Insert pbx agent
     *
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxAgentWithHttpInfo($pbx_agent)
    {
        return $this->insertPbxAgentWithHttpInfoRetry(true ,   $pbx_agent);
    }


    /**
     * Operation insertPbxAgentWithHttpInfoRetry
     *
     * Insert pbx agent
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxAgentWithHttpInfoRetry($retry ,  $pbx_agent)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentResponse';
        $request = $this->insertPbxAgentRequest($pbx_agent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertPbxAgentWithHttpInfoRetry(false ,   $pbx_agent);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAgentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertPbxAgentAsync
     *
     * Insert pbx agent
     *
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxAgentAsync($pbx_agent)
    {
        return $this->insertPbxAgentAsyncWithHttpInfo($pbx_agent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertPbxAgentAsyncWithHttpInfo
     *
     * Insert pbx agent
     *
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxAgentAsyncWithHttpInfo($pbx_agent)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentResponse';
        $request = $this->insertPbxAgentRequest($pbx_agent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertPbxAgent'
     *
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertPbxAgentRequest($pbx_agent)
    {
        // verify the required parameter 'pbx_agent' is set
        if ($pbx_agent === null || (is_array($pbx_agent) && count($pbx_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_agent when calling insertPbxAgent'
            );
        }

        $resourcePath = '/conversation/pbx/agent';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pbx_agent)) {
            $_tempBody = $pbx_agent;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertPbxAudio
     *
     * Insert pbx audio
     *
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAudioResponse
     */
    public function insertPbxAudio($pbx_audio)
    {
        list($response) = $this->insertPbxAudioWithHttpInfo($pbx_audio);
        return $response;
    }


    /**
     * Operation insertPbxAudioWithHttpInfo
     *
     * Insert pbx audio
     *
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudioResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxAudioWithHttpInfo($pbx_audio)
    {
        return $this->insertPbxAudioWithHttpInfoRetry(true ,   $pbx_audio);
    }


    /**
     * Operation insertPbxAudioWithHttpInfoRetry
     *
     * Insert pbx audio
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudioResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxAudioWithHttpInfoRetry($retry ,  $pbx_audio)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudioResponse';
        $request = $this->insertPbxAudioRequest($pbx_audio);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertPbxAudioWithHttpInfoRetry(false ,   $pbx_audio);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAudioResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertPbxAudioAsync
     *
     * Insert pbx audio
     *
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxAudioAsync($pbx_audio)
    {
        return $this->insertPbxAudioAsyncWithHttpInfo($pbx_audio)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertPbxAudioAsyncWithHttpInfo
     *
     * Insert pbx audio
     *
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxAudioAsyncWithHttpInfo($pbx_audio)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudioResponse';
        $request = $this->insertPbxAudioRequest($pbx_audio);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertPbxAudio'
     *
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertPbxAudioRequest($pbx_audio)
    {
        // verify the required parameter 'pbx_audio' is set
        if ($pbx_audio === null || (is_array($pbx_audio) && count($pbx_audio) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_audio when calling insertPbxAudio'
            );
        }

        $resourcePath = '/conversation/pbx/audio';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pbx_audio)) {
            $_tempBody = $pbx_audio;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertPbxMenu
     *
     * Insert pbx menu
     *
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxMenuResponse
     */
    public function insertPbxMenu($pbx_menu)
    {
        list($response) = $this->insertPbxMenuWithHttpInfo($pbx_menu);
        return $response;
    }


    /**
     * Operation insertPbxMenuWithHttpInfo
     *
     * Insert pbx menu
     *
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxMenuWithHttpInfo($pbx_menu)
    {
        return $this->insertPbxMenuWithHttpInfoRetry(true ,   $pbx_menu);
    }


    /**
     * Operation insertPbxMenuWithHttpInfoRetry
     *
     * Insert pbx menu
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxMenuWithHttpInfoRetry($retry ,  $pbx_menu)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenuResponse';
        $request = $this->insertPbxMenuRequest($pbx_menu);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertPbxMenuWithHttpInfoRetry(false ,   $pbx_menu);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxMenuResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertPbxMenuAsync
     *
     * Insert pbx menu
     *
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxMenuAsync($pbx_menu)
    {
        return $this->insertPbxMenuAsyncWithHttpInfo($pbx_menu)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertPbxMenuAsyncWithHttpInfo
     *
     * Insert pbx menu
     *
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxMenuAsyncWithHttpInfo($pbx_menu)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenuResponse';
        $request = $this->insertPbxMenuRequest($pbx_menu);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertPbxMenu'
     *
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertPbxMenuRequest($pbx_menu)
    {
        // verify the required parameter 'pbx_menu' is set
        if ($pbx_menu === null || (is_array($pbx_menu) && count($pbx_menu) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_menu when calling insertPbxMenu'
            );
        }

        $resourcePath = '/conversation/pbx/menu';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pbx_menu)) {
            $_tempBody = $pbx_menu;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertPbxPhoneNumber
     *
     * Insert pbx phoneNumber
     *
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxPhoneNumberResponse
     */
    public function insertPbxPhoneNumber($pbx_phone_number)
    {
        list($response) = $this->insertPbxPhoneNumberWithHttpInfo($pbx_phone_number);
        return $response;
    }


    /**
     * Operation insertPbxPhoneNumberWithHttpInfo
     *
     * Insert pbx phoneNumber
     *
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxPhoneNumberWithHttpInfo($pbx_phone_number)
    {
        return $this->insertPbxPhoneNumberWithHttpInfoRetry(true ,   $pbx_phone_number);
    }


    /**
     * Operation insertPbxPhoneNumberWithHttpInfoRetry
     *
     * Insert pbx phoneNumber
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxPhoneNumberWithHttpInfoRetry($retry ,  $pbx_phone_number)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumberResponse';
        $request = $this->insertPbxPhoneNumberRequest($pbx_phone_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertPbxPhoneNumberWithHttpInfoRetry(false ,   $pbx_phone_number);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxPhoneNumberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertPbxPhoneNumberAsync
     *
     * Insert pbx phoneNumber
     *
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxPhoneNumberAsync($pbx_phone_number)
    {
        return $this->insertPbxPhoneNumberAsyncWithHttpInfo($pbx_phone_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertPbxPhoneNumberAsyncWithHttpInfo
     *
     * Insert pbx phoneNumber
     *
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxPhoneNumberAsyncWithHttpInfo($pbx_phone_number)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumberResponse';
        $request = $this->insertPbxPhoneNumberRequest($pbx_phone_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertPbxPhoneNumber'
     *
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertPbxPhoneNumberRequest($pbx_phone_number)
    {
        // verify the required parameter 'pbx_phone_number' is set
        if ($pbx_phone_number === null || (is_array($pbx_phone_number) && count($pbx_phone_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_phone_number when calling insertPbxPhoneNumber'
            );
        }

        $resourcePath = '/conversation/pbx/phone_number';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pbx_phone_number)) {
            $_tempBody = $pbx_phone_number;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertPbxQueue
     *
     * Insert pbx queue
     *
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxQueueResponse
     */
    public function insertPbxQueue($pbx_queue)
    {
        list($response) = $this->insertPbxQueueWithHttpInfo($pbx_queue);
        return $response;
    }


    /**
     * Operation insertPbxQueueWithHttpInfo
     *
     * Insert pbx queue
     *
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueueResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxQueueWithHttpInfo($pbx_queue)
    {
        return $this->insertPbxQueueWithHttpInfoRetry(true ,   $pbx_queue);
    }


    /**
     * Operation insertPbxQueueWithHttpInfoRetry
     *
     * Insert pbx queue
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueueResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxQueueWithHttpInfoRetry($retry ,  $pbx_queue)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueueResponse';
        $request = $this->insertPbxQueueRequest($pbx_queue);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertPbxQueueWithHttpInfoRetry(false ,   $pbx_queue);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxQueueResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertPbxQueueAsync
     *
     * Insert pbx queue
     *
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxQueueAsync($pbx_queue)
    {
        return $this->insertPbxQueueAsyncWithHttpInfo($pbx_queue)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertPbxQueueAsyncWithHttpInfo
     *
     * Insert pbx queue
     *
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxQueueAsyncWithHttpInfo($pbx_queue)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueueResponse';
        $request = $this->insertPbxQueueRequest($pbx_queue);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertPbxQueue'
     *
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertPbxQueueRequest($pbx_queue)
    {
        // verify the required parameter 'pbx_queue' is set
        if ($pbx_queue === null || (is_array($pbx_queue) && count($pbx_queue) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_queue when calling insertPbxQueue'
            );
        }

        $resourcePath = '/conversation/pbx/queue';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pbx_queue)) {
            $_tempBody = $pbx_queue;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertPbxTimeBased
     *
     * Insert pbx timeBased
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeBasedResponse
     */
    public function insertPbxTimeBased($pbx_time_based)
    {
        list($response) = $this->insertPbxTimeBasedWithHttpInfo($pbx_time_based);
        return $response;
    }


    /**
     * Operation insertPbxTimeBasedWithHttpInfo
     *
     * Insert pbx timeBased
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxTimeBasedWithHttpInfo($pbx_time_based)
    {
        return $this->insertPbxTimeBasedWithHttpInfoRetry(true ,   $pbx_time_based);
    }


    /**
     * Operation insertPbxTimeBasedWithHttpInfoRetry
     *
     * Insert pbx timeBased
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxTimeBasedWithHttpInfoRetry($retry ,  $pbx_time_based)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedResponse';
        $request = $this->insertPbxTimeBasedRequest($pbx_time_based);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertPbxTimeBasedWithHttpInfoRetry(false ,   $pbx_time_based);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeBasedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertPbxTimeBasedAsync
     *
     * Insert pbx timeBased
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxTimeBasedAsync($pbx_time_based)
    {
        return $this->insertPbxTimeBasedAsyncWithHttpInfo($pbx_time_based)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertPbxTimeBasedAsyncWithHttpInfo
     *
     * Insert pbx timeBased
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxTimeBasedAsyncWithHttpInfo($pbx_time_based)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedResponse';
        $request = $this->insertPbxTimeBasedRequest($pbx_time_based);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertPbxTimeBased'
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertPbxTimeBasedRequest($pbx_time_based)
    {
        // verify the required parameter 'pbx_time_based' is set
        if ($pbx_time_based === null || (is_array($pbx_time_based) && count($pbx_time_based) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_time_based when calling insertPbxTimeBased'
            );
        }

        $resourcePath = '/conversation/pbx/time_based';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pbx_time_based)) {
            $_tempBody = $pbx_time_based;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertPbxTimeRange
     *
     * Insert pbx timeRange
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeRangeResponse
     */
    public function insertPbxTimeRange($pbx_time_range)
    {
        list($response) = $this->insertPbxTimeRangeWithHttpInfo($pbx_time_range);
        return $response;
    }


    /**
     * Operation insertPbxTimeRangeWithHttpInfo
     *
     * Insert pbx timeRange
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxTimeRangeWithHttpInfo($pbx_time_range)
    {
        return $this->insertPbxTimeRangeWithHttpInfoRetry(true ,   $pbx_time_range);
    }


    /**
     * Operation insertPbxTimeRangeWithHttpInfoRetry
     *
     * Insert pbx timeRange
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxTimeRangeWithHttpInfoRetry($retry ,  $pbx_time_range)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangeResponse';
        $request = $this->insertPbxTimeRangeRequest($pbx_time_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertPbxTimeRangeWithHttpInfoRetry(false ,   $pbx_time_range);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeRangeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertPbxTimeRangeAsync
     *
     * Insert pbx timeRange
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxTimeRangeAsync($pbx_time_range)
    {
        return $this->insertPbxTimeRangeAsyncWithHttpInfo($pbx_time_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertPbxTimeRangeAsyncWithHttpInfo
     *
     * Insert pbx timeRange
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxTimeRangeAsyncWithHttpInfo($pbx_time_range)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangeResponse';
        $request = $this->insertPbxTimeRangeRequest($pbx_time_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertPbxTimeRange'
     *
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertPbxTimeRangeRequest($pbx_time_range)
    {
        // verify the required parameter 'pbx_time_range' is set
        if ($pbx_time_range === null || (is_array($pbx_time_range) && count($pbx_time_range) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_time_range when calling insertPbxTimeRange'
            );
        }

        $resourcePath = '/conversation/pbx/time_range';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pbx_time_range)) {
            $_tempBody = $pbx_time_range;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation insertPbxVoicemailMailbox
     *
     * Insert pbx voicemailMailbox
     *
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse
     */
    public function insertPbxVoicemailMailbox($pbx_voicemail_mailbox)
    {
        list($response) = $this->insertPbxVoicemailMailboxWithHttpInfo($pbx_voicemail_mailbox);
        return $response;
    }


    /**
     * Operation insertPbxVoicemailMailboxWithHttpInfo
     *
     * Insert pbx voicemailMailbox
     *
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxVoicemailMailboxWithHttpInfo($pbx_voicemail_mailbox)
    {
        return $this->insertPbxVoicemailMailboxWithHttpInfoRetry(true ,   $pbx_voicemail_mailbox);
    }


    /**
     * Operation insertPbxVoicemailMailboxWithHttpInfoRetry
     *
     * Insert pbx voicemailMailbox
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function insertPbxVoicemailMailboxWithHttpInfoRetry($retry ,  $pbx_voicemail_mailbox)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse';
        $request = $this->insertPbxVoicemailMailboxRequest($pbx_voicemail_mailbox);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->insertPbxVoicemailMailboxWithHttpInfoRetry(false ,   $pbx_voicemail_mailbox);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation insertPbxVoicemailMailboxAsync
     *
     * Insert pbx voicemailMailbox
     *
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxVoicemailMailboxAsync($pbx_voicemail_mailbox)
    {
        return $this->insertPbxVoicemailMailboxAsyncWithHttpInfo($pbx_voicemail_mailbox)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation insertPbxVoicemailMailboxAsyncWithHttpInfo
     *
     * Insert pbx voicemailMailbox
     *
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function insertPbxVoicemailMailboxAsyncWithHttpInfo($pbx_voicemail_mailbox)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse';
        $request = $this->insertPbxVoicemailMailboxRequest($pbx_voicemail_mailbox);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'insertPbxVoicemailMailbox'
     *
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function insertPbxVoicemailMailboxRequest($pbx_voicemail_mailbox)
    {
        // verify the required parameter 'pbx_voicemail_mailbox' is set
        if ($pbx_voicemail_mailbox === null || (is_array($pbx_voicemail_mailbox) && count($pbx_voicemail_mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_voicemail_mailbox when calling insertPbxVoicemailMailbox'
            );
        }

        $resourcePath = '/conversation/pbx/voicemail_mailbox';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($pbx_voicemail_mailbox)) {
            $_tempBody = $pbx_voicemail_mailbox;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation joinConversation
     *
     * Join a conversation
     *
     * @param  string $conversation_uuid conversation_uuid (required)
     * @param  \ultracart\v2\models\ConversationJoinRequest $join_request Join request (optional)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function joinConversation($conversation_uuid, $join_request = null)
    {
        $this->joinConversationWithHttpInfo($conversation_uuid, $join_request);
    }


    /**
     * Operation joinConversationWithHttpInfo
     *
     * Join a conversation
     *
     * @param  string $conversation_uuid (required)
     * @param  \ultracart\v2\models\ConversationJoinRequest $join_request Join request (optional)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function joinConversationWithHttpInfo($conversation_uuid, $join_request = null)
    {
        $this->joinConversationWithHttpInfoRetry(true ,   $conversation_uuid,   $join_request);
    }


    /**
     * Operation joinConversationWithHttpInfoRetry
     *
     * Join a conversation
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_uuid (required)
     * @param  \ultracart\v2\models\ConversationJoinRequest $join_request Join request (optional)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function joinConversationWithHttpInfoRetry($retry ,  $conversation_uuid,  $join_request = null)
    {
        $returnType = '';
        $request = $this->joinConversationRequest($conversation_uuid, $join_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->joinConversationWithHttpInfoRetry(false ,   $conversation_uuid,   $join_request);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation joinConversationAsync
     *
     * Join a conversation
     *
     * @param  string $conversation_uuid (required)
     * @param  \ultracart\v2\models\ConversationJoinRequest $join_request Join request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function joinConversationAsync($conversation_uuid, $join_request = null)
    {
        return $this->joinConversationAsyncWithHttpInfo($conversation_uuid, $join_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation joinConversationAsyncWithHttpInfo
     *
     * Join a conversation
     *
     * @param  string $conversation_uuid (required)
     * @param  \ultracart\v2\models\ConversationJoinRequest $join_request Join request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function joinConversationAsyncWithHttpInfo($conversation_uuid, $join_request = null)
    {
        $returnType = '';
        $request = $this->joinConversationRequest($conversation_uuid, $join_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'joinConversation'
     *
     * @param  string $conversation_uuid (required)
     * @param  \ultracart\v2\models\ConversationJoinRequest $join_request Join request (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function joinConversationRequest($conversation_uuid, $join_request = null)
    {
        // verify the required parameter 'conversation_uuid' is set
        if ($conversation_uuid === null || (is_array($conversation_uuid) && count($conversation_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_uuid when calling joinConversation'
            );
        }

        $resourcePath = '/conversation/conversations/{conversation_uuid}/join';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_uuid' . '}',
                ObjectSerializer::toPathValue($conversation_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($join_request)) {
            $_tempBody = $join_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation leaveConversation
     *
     * Leave a conversation
     *
     * @param  string $conversation_uuid conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function leaveConversation($conversation_uuid)
    {
        $this->leaveConversationWithHttpInfo($conversation_uuid);
    }


    /**
     * Operation leaveConversationWithHttpInfo
     *
     * Leave a conversation
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveConversationWithHttpInfo($conversation_uuid)
    {
        $this->leaveConversationWithHttpInfoRetry(true ,   $conversation_uuid);
    }


    /**
     * Operation leaveConversationWithHttpInfoRetry
     *
     * Leave a conversation
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function leaveConversationWithHttpInfoRetry($retry ,  $conversation_uuid)
    {
        $returnType = '';
        $request = $this->leaveConversationRequest($conversation_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->leaveConversationWithHttpInfoRetry(false ,   $conversation_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation leaveConversationAsync
     *
     * Leave a conversation
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveConversationAsync($conversation_uuid)
    {
        return $this->leaveConversationAsyncWithHttpInfo($conversation_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation leaveConversationAsyncWithHttpInfo
     *
     * Leave a conversation
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function leaveConversationAsyncWithHttpInfo($conversation_uuid)
    {
        $returnType = '';
        $request = $this->leaveConversationRequest($conversation_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'leaveConversation'
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function leaveConversationRequest($conversation_uuid)
    {
        // verify the required parameter 'conversation_uuid' is set
        if ($conversation_uuid === null || (is_array($conversation_uuid) && count($conversation_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_uuid when calling leaveConversation'
            );
        }

        $resourcePath = '/conversation/conversations/{conversation_uuid}/leave';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_uuid' . '}',
                ObjectSerializer::toPathValue($conversation_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listenedPbxAgentVoicemail
     *
     * Listened Agent Voicemail
     *
     * @param  string $recording_sid recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function listenedPbxAgentVoicemail($recording_sid)
    {
        $this->listenedPbxAgentVoicemailWithHttpInfo($recording_sid);
    }


    /**
     * Operation listenedPbxAgentVoicemailWithHttpInfo
     *
     * Listened Agent Voicemail
     *
     * @param  string $recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listenedPbxAgentVoicemailWithHttpInfo($recording_sid)
    {
        $this->listenedPbxAgentVoicemailWithHttpInfoRetry(true ,   $recording_sid);
    }


    /**
     * Operation listenedPbxAgentVoicemailWithHttpInfoRetry
     *
     * Listened Agent Voicemail
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $recording_sid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function listenedPbxAgentVoicemailWithHttpInfoRetry($retry ,  $recording_sid)
    {
        $returnType = '';
        $request = $this->listenedPbxAgentVoicemailRequest($recording_sid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->listenedPbxAgentVoicemailWithHttpInfoRetry(false ,   $recording_sid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listenedPbxAgentVoicemailAsync
     *
     * Listened Agent Voicemail
     *
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listenedPbxAgentVoicemailAsync($recording_sid)
    {
        return $this->listenedPbxAgentVoicemailAsyncWithHttpInfo($recording_sid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listenedPbxAgentVoicemailAsyncWithHttpInfo
     *
     * Listened Agent Voicemail
     *
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listenedPbxAgentVoicemailAsyncWithHttpInfo($recording_sid)
    {
        $returnType = '';
        $request = $this->listenedPbxAgentVoicemailRequest($recording_sid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listenedPbxAgentVoicemail'
     *
     * @param  string $recording_sid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listenedPbxAgentVoicemailRequest($recording_sid)
    {
        // verify the required parameter 'recording_sid' is set
        if ($recording_sid === null || (is_array($recording_sid) && count($recording_sid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $recording_sid when calling listenedPbxAgentVoicemail'
            );
        }

        $resourcePath = '/conversation/pbx/agent/voicemails/{recording_sid}/listened';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($recording_sid !== null) {
            $resourcePath = str_replace(
                '{' . 'recording_sid' . '}',
                ObjectSerializer::toPathValue($recording_sid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation markReadConversation
     *
     * Mark a conversation as read
     *
     * @param  string $conversation_uuid conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function markReadConversation($conversation_uuid)
    {
        $this->markReadConversationWithHttpInfo($conversation_uuid);
    }


    /**
     * Operation markReadConversationWithHttpInfo
     *
     * Mark a conversation as read
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function markReadConversationWithHttpInfo($conversation_uuid)
    {
        $this->markReadConversationWithHttpInfoRetry(true ,   $conversation_uuid);
    }


    /**
     * Operation markReadConversationWithHttpInfoRetry
     *
     * Mark a conversation as read
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function markReadConversationWithHttpInfoRetry($retry ,  $conversation_uuid)
    {
        $returnType = '';
        $request = $this->markReadConversationRequest($conversation_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->markReadConversationWithHttpInfoRetry(false ,   $conversation_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation markReadConversationAsync
     *
     * Mark a conversation as read
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markReadConversationAsync($conversation_uuid)
    {
        return $this->markReadConversationAsyncWithHttpInfo($conversation_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation markReadConversationAsyncWithHttpInfo
     *
     * Mark a conversation as read
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function markReadConversationAsyncWithHttpInfo($conversation_uuid)
    {
        $returnType = '';
        $request = $this->markReadConversationRequest($conversation_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'markReadConversation'
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function markReadConversationRequest($conversation_uuid)
    {
        // verify the required parameter 'conversation_uuid' is set
        if ($conversation_uuid === null || (is_array($conversation_uuid) && count($conversation_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_uuid when calling markReadConversation'
            );
        }

        $resourcePath = '/conversation/conversations/{conversation_uuid}/markread';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_uuid' . '}',
                ObjectSerializer::toPathValue($conversation_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation resetConversationPbxQueueStatistics
     *
     * reset statistics within the queue
     *
     * @param  string $queue_uuid queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function resetConversationPbxQueueStatistics($queue_uuid)
    {
        $this->resetConversationPbxQueueStatisticsWithHttpInfo($queue_uuid);
    }


    /**
     * Operation resetConversationPbxQueueStatisticsWithHttpInfo
     *
     * reset statistics within the queue
     *
     * @param  string $queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetConversationPbxQueueStatisticsWithHttpInfo($queue_uuid)
    {
        $this->resetConversationPbxQueueStatisticsWithHttpInfoRetry(true ,   $queue_uuid);
    }


    /**
     * Operation resetConversationPbxQueueStatisticsWithHttpInfoRetry
     *
     * reset statistics within the queue
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $queue_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function resetConversationPbxQueueStatisticsWithHttpInfoRetry($retry ,  $queue_uuid)
    {
        $returnType = '';
        $request = $this->resetConversationPbxQueueStatisticsRequest($queue_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->resetConversationPbxQueueStatisticsWithHttpInfoRetry(false ,   $queue_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation resetConversationPbxQueueStatisticsAsync
     *
     * reset statistics within the queue
     *
     * @param  string $queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetConversationPbxQueueStatisticsAsync($queue_uuid)
    {
        return $this->resetConversationPbxQueueStatisticsAsyncWithHttpInfo($queue_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation resetConversationPbxQueueStatisticsAsyncWithHttpInfo
     *
     * reset statistics within the queue
     *
     * @param  string $queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function resetConversationPbxQueueStatisticsAsyncWithHttpInfo($queue_uuid)
    {
        $returnType = '';
        $request = $this->resetConversationPbxQueueStatisticsRequest($queue_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'resetConversationPbxQueueStatistics'
     *
     * @param  string $queue_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function resetConversationPbxQueueStatisticsRequest($queue_uuid)
    {
        // verify the required parameter 'queue_uuid' is set
        if ($queue_uuid === null || (is_array($queue_uuid) && count($queue_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_uuid when calling resetConversationPbxQueueStatistics'
            );
        }

        $resourcePath = '/conversation/pbx/queues/{queue_uuid}/reset_statistics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($queue_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'queue_uuid' . '}',
                ObjectSerializer::toPathValue($queue_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation searchConversationCannedMessages
     *
     * Search for canned messages by short_code
     *
     * @param  \ultracart\v2\models\ConversationCannedMessagesSearch $search_request Search request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationCannedMessagesResponse
     */
    public function searchConversationCannedMessages($search_request)
    {
        list($response) = $this->searchConversationCannedMessagesWithHttpInfo($search_request);
        return $response;
    }


    /**
     * Operation searchConversationCannedMessagesWithHttpInfo
     *
     * Search for canned messages by short_code
     *
     * @param  \ultracart\v2\models\ConversationCannedMessagesSearch $search_request Search request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationCannedMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchConversationCannedMessagesWithHttpInfo($search_request)
    {
        return $this->searchConversationCannedMessagesWithHttpInfoRetry(true ,   $search_request);
    }


    /**
     * Operation searchConversationCannedMessagesWithHttpInfoRetry
     *
     * Search for canned messages by short_code
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationCannedMessagesSearch $search_request Search request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationCannedMessagesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function searchConversationCannedMessagesWithHttpInfoRetry($retry ,  $search_request)
    {
        $returnType = '\ultracart\v2\models\ConversationCannedMessagesResponse';
        $request = $this->searchConversationCannedMessagesRequest($search_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->searchConversationCannedMessagesWithHttpInfoRetry(false ,   $search_request);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationCannedMessagesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation searchConversationCannedMessagesAsync
     *
     * Search for canned messages by short_code
     *
     * @param  \ultracart\v2\models\ConversationCannedMessagesSearch $search_request Search request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchConversationCannedMessagesAsync($search_request)
    {
        return $this->searchConversationCannedMessagesAsyncWithHttpInfo($search_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation searchConversationCannedMessagesAsyncWithHttpInfo
     *
     * Search for canned messages by short_code
     *
     * @param  \ultracart\v2\models\ConversationCannedMessagesSearch $search_request Search request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function searchConversationCannedMessagesAsyncWithHttpInfo($search_request)
    {
        $returnType = '\ultracart\v2\models\ConversationCannedMessagesResponse';
        $request = $this->searchConversationCannedMessagesRequest($search_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'searchConversationCannedMessages'
     *
     * @param  \ultracart\v2\models\ConversationCannedMessagesSearch $search_request Search request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function searchConversationCannedMessagesRequest($search_request)
    {
        // verify the required parameter 'search_request' is set
        if ($search_request === null || (is_array($search_request) && count($search_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $search_request when calling searchConversationCannedMessages'
            );
        }

        $resourcePath = '/conversation/canned_messages/search';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($search_request)) {
            $_tempBody = $search_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation smsUnsubscribeConversation
     *
     * Unsubscribe any SMS participants in this conversation
     *
     * @param  string $conversation_uuid conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function smsUnsubscribeConversation($conversation_uuid)
    {
        $this->smsUnsubscribeConversationWithHttpInfo($conversation_uuid);
    }


    /**
     * Operation smsUnsubscribeConversationWithHttpInfo
     *
     * Unsubscribe any SMS participants in this conversation
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function smsUnsubscribeConversationWithHttpInfo($conversation_uuid)
    {
        $this->smsUnsubscribeConversationWithHttpInfoRetry(true ,   $conversation_uuid);
    }


    /**
     * Operation smsUnsubscribeConversationWithHttpInfoRetry
     *
     * Unsubscribe any SMS participants in this conversation
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_uuid (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function smsUnsubscribeConversationWithHttpInfoRetry($retry ,  $conversation_uuid)
    {
        $returnType = '';
        $request = $this->smsUnsubscribeConversationRequest($conversation_uuid);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->smsUnsubscribeConversationWithHttpInfoRetry(false ,   $conversation_uuid);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation smsUnsubscribeConversationAsync
     *
     * Unsubscribe any SMS participants in this conversation
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function smsUnsubscribeConversationAsync($conversation_uuid)
    {
        return $this->smsUnsubscribeConversationAsyncWithHttpInfo($conversation_uuid)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation smsUnsubscribeConversationAsyncWithHttpInfo
     *
     * Unsubscribe any SMS participants in this conversation
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function smsUnsubscribeConversationAsyncWithHttpInfo($conversation_uuid)
    {
        $returnType = '';
        $request = $this->smsUnsubscribeConversationRequest($conversation_uuid);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'smsUnsubscribeConversation'
     *
     * @param  string $conversation_uuid (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function smsUnsubscribeConversationRequest($conversation_uuid)
    {
        // verify the required parameter 'conversation_uuid' is set
        if ($conversation_uuid === null || (is_array($conversation_uuid) && count($conversation_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_uuid when calling smsUnsubscribeConversation'
            );
        }

        $resourcePath = '/conversation/conversations/{conversation_uuid}/sms_unsubscribe';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_uuid' . '}',
                ObjectSerializer::toPathValue($conversation_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation startConversation
     *
     * Start a conversation
     *
     * @param  \ultracart\v2\models\ConversationStartRequest $start_request Start request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationStartResponse
     */
    public function startConversation($start_request)
    {
        list($response) = $this->startConversationWithHttpInfo($start_request);
        return $response;
    }


    /**
     * Operation startConversationWithHttpInfo
     *
     * Start a conversation
     *
     * @param  \ultracart\v2\models\ConversationStartRequest $start_request Start request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationStartResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function startConversationWithHttpInfo($start_request)
    {
        return $this->startConversationWithHttpInfoRetry(true ,   $start_request);
    }


    /**
     * Operation startConversationWithHttpInfoRetry
     *
     * Start a conversation
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationStartRequest $start_request Start request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationStartResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function startConversationWithHttpInfoRetry($retry ,  $start_request)
    {
        $returnType = '\ultracart\v2\models\ConversationStartResponse';
        $request = $this->startConversationRequest($start_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->startConversationWithHttpInfoRetry(false ,   $start_request);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationStartResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation startConversationAsync
     *
     * Start a conversation
     *
     * @param  \ultracart\v2\models\ConversationStartRequest $start_request Start request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startConversationAsync($start_request)
    {
        return $this->startConversationAsyncWithHttpInfo($start_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation startConversationAsyncWithHttpInfo
     *
     * Start a conversation
     *
     * @param  \ultracart\v2\models\ConversationStartRequest $start_request Start request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function startConversationAsyncWithHttpInfo($start_request)
    {
        $returnType = '\ultracart\v2\models\ConversationStartResponse';
        $request = $this->startConversationRequest($start_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'startConversation'
     *
     * @param  \ultracart\v2\models\ConversationStartRequest $start_request Start request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function startConversationRequest($start_request)
    {
        // verify the required parameter 'start_request' is set
        if ($start_request === null || (is_array($start_request) && count($start_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $start_request when calling startConversation'
            );
        }

        $resourcePath = '/conversation/conversations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($start_request)) {
            $_tempBody = $start_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateAgentProfile
     *
     * Update agent profile
     *
     * @param  \ultracart\v2\models\ConversationAgentProfile $profile_request Profile request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationAgentProfileResponse
     */
    public function updateAgentProfile($profile_request)
    {
        list($response) = $this->updateAgentProfileWithHttpInfo($profile_request);
        return $response;
    }


    /**
     * Operation updateAgentProfileWithHttpInfo
     *
     * Update agent profile
     *
     * @param  \ultracart\v2\models\ConversationAgentProfile $profile_request Profile request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationAgentProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAgentProfileWithHttpInfo($profile_request)
    {
        return $this->updateAgentProfileWithHttpInfoRetry(true ,   $profile_request);
    }


    /**
     * Operation updateAgentProfileWithHttpInfoRetry
     *
     * Update agent profile
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  \ultracart\v2\models\ConversationAgentProfile $profile_request Profile request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationAgentProfileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateAgentProfileWithHttpInfoRetry($retry ,  $profile_request)
    {
        $returnType = '\ultracart\v2\models\ConversationAgentProfileResponse';
        $request = $this->updateAgentProfileRequest($profile_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updateAgentProfileWithHttpInfoRetry(false ,   $profile_request);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationAgentProfileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateAgentProfileAsync
     *
     * Update agent profile
     *
     * @param  \ultracart\v2\models\ConversationAgentProfile $profile_request Profile request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAgentProfileAsync($profile_request)
    {
        return $this->updateAgentProfileAsyncWithHttpInfo($profile_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateAgentProfileAsyncWithHttpInfo
     *
     * Update agent profile
     *
     * @param  \ultracart\v2\models\ConversationAgentProfile $profile_request Profile request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateAgentProfileAsyncWithHttpInfo($profile_request)
    {
        $returnType = '\ultracart\v2\models\ConversationAgentProfileResponse';
        $request = $this->updateAgentProfileRequest($profile_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateAgentProfile'
     *
     * @param  \ultracart\v2\models\ConversationAgentProfile $profile_request Profile request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateAgentProfileRequest($profile_request)
    {
        // verify the required parameter 'profile_request' is set
        if ($profile_request === null || (is_array($profile_request) && count($profile_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $profile_request when calling updateAgentProfile'
            );
        }

        $resourcePath = '/conversation/agent/profile';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($profile_request)) {
            $_tempBody = $profile_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateConversationCannedMessage
     *
     * Update a canned message
     *
     * @param  int $conversation_canned_message_oid conversation_canned_message_oid (required)
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationCannedMessageResponse
     */
    public function updateConversationCannedMessage($conversation_canned_message_oid, $canned_message)
    {
        list($response) = $this->updateConversationCannedMessageWithHttpInfo($conversation_canned_message_oid, $canned_message);
        return $response;
    }


    /**
     * Operation updateConversationCannedMessageWithHttpInfo
     *
     * Update a canned message
     *
     * @param  int $conversation_canned_message_oid (required)
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationCannedMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConversationCannedMessageWithHttpInfo($conversation_canned_message_oid, $canned_message)
    {
        return $this->updateConversationCannedMessageWithHttpInfoRetry(true ,   $conversation_canned_message_oid,   $canned_message);
    }


    /**
     * Operation updateConversationCannedMessageWithHttpInfoRetry
     *
     * Update a canned message
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  int $conversation_canned_message_oid (required)
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationCannedMessageResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConversationCannedMessageWithHttpInfoRetry($retry ,  $conversation_canned_message_oid,  $canned_message)
    {
        $returnType = '\ultracart\v2\models\ConversationCannedMessageResponse';
        $request = $this->updateConversationCannedMessageRequest($conversation_canned_message_oid, $canned_message);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updateConversationCannedMessageWithHttpInfoRetry(false ,   $conversation_canned_message_oid,   $canned_message);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationCannedMessageResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateConversationCannedMessageAsync
     *
     * Update a canned message
     *
     * @param  int $conversation_canned_message_oid (required)
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConversationCannedMessageAsync($conversation_canned_message_oid, $canned_message)
    {
        return $this->updateConversationCannedMessageAsyncWithHttpInfo($conversation_canned_message_oid, $canned_message)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateConversationCannedMessageAsyncWithHttpInfo
     *
     * Update a canned message
     *
     * @param  int $conversation_canned_message_oid (required)
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConversationCannedMessageAsyncWithHttpInfo($conversation_canned_message_oid, $canned_message)
    {
        $returnType = '\ultracart\v2\models\ConversationCannedMessageResponse';
        $request = $this->updateConversationCannedMessageRequest($conversation_canned_message_oid, $canned_message);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateConversationCannedMessage'
     *
     * @param  int $conversation_canned_message_oid (required)
     * @param  \ultracart\v2\models\ConversationCannedMessage $canned_message Canned message (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateConversationCannedMessageRequest($conversation_canned_message_oid, $canned_message)
    {
        // verify the required parameter 'conversation_canned_message_oid' is set
        if ($conversation_canned_message_oid === null || (is_array($conversation_canned_message_oid) && count($conversation_canned_message_oid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_canned_message_oid when calling updateConversationCannedMessage'
            );
        }
        // verify the required parameter 'canned_message' is set
        if ($canned_message === null || (is_array($canned_message) && count($canned_message) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $canned_message when calling updateConversationCannedMessage'
            );
        }

        $resourcePath = '/conversation/canned_messages/{conversation_canned_message_oid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_canned_message_oid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_canned_message_oid' . '}',
                ObjectSerializer::toPathValue($conversation_canned_message_oid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($canned_message)) {
            $_tempBody = $canned_message;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateConversationDepartment
     *
     * Update a department
     *
     * @param  int $conversation_department_oid conversation_department_oid (required)
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationDepartmentResponse
     */
    public function updateConversationDepartment($conversation_department_oid, $department)
    {
        list($response) = $this->updateConversationDepartmentWithHttpInfo($conversation_department_oid, $department);
        return $response;
    }


    /**
     * Operation updateConversationDepartmentWithHttpInfo
     *
     * Update a department
     *
     * @param  int $conversation_department_oid (required)
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationDepartmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConversationDepartmentWithHttpInfo($conversation_department_oid, $department)
    {
        return $this->updateConversationDepartmentWithHttpInfoRetry(true ,   $conversation_department_oid,   $department);
    }


    /**
     * Operation updateConversationDepartmentWithHttpInfoRetry
     *
     * Update a department
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  int $conversation_department_oid (required)
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationDepartmentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConversationDepartmentWithHttpInfoRetry($retry ,  $conversation_department_oid,  $department)
    {
        $returnType = '\ultracart\v2\models\ConversationDepartmentResponse';
        $request = $this->updateConversationDepartmentRequest($conversation_department_oid, $department);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updateConversationDepartmentWithHttpInfoRetry(false ,   $conversation_department_oid,   $department);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationDepartmentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateConversationDepartmentAsync
     *
     * Update a department
     *
     * @param  int $conversation_department_oid (required)
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConversationDepartmentAsync($conversation_department_oid, $department)
    {
        return $this->updateConversationDepartmentAsyncWithHttpInfo($conversation_department_oid, $department)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateConversationDepartmentAsyncWithHttpInfo
     *
     * Update a department
     *
     * @param  int $conversation_department_oid (required)
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConversationDepartmentAsyncWithHttpInfo($conversation_department_oid, $department)
    {
        $returnType = '\ultracart\v2\models\ConversationDepartmentResponse';
        $request = $this->updateConversationDepartmentRequest($conversation_department_oid, $department);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateConversationDepartment'
     *
     * @param  int $conversation_department_oid (required)
     * @param  \ultracart\v2\models\ConversationDepartment $department Department (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateConversationDepartmentRequest($conversation_department_oid, $department)
    {
        // verify the required parameter 'conversation_department_oid' is set
        if ($conversation_department_oid === null || (is_array($conversation_department_oid) && count($conversation_department_oid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_department_oid when calling updateConversationDepartment'
            );
        }
        // verify the required parameter 'department' is set
        if ($department === null || (is_array($department) && count($department) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $department when calling updateConversationDepartment'
            );
        }

        $resourcePath = '/conversation/departments/{conversation_department_oid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_department_oid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_department_oid' . '}',
                ObjectSerializer::toPathValue($conversation_department_oid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($department)) {
            $_tempBody = $department;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateConversationEngagement
     *
     * Update a engagement
     *
     * @param  int $conversation_engagement_oid conversation_engagement_oid (required)
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationEngagementResponse
     */
    public function updateConversationEngagement($conversation_engagement_oid, $engagement)
    {
        list($response) = $this->updateConversationEngagementWithHttpInfo($conversation_engagement_oid, $engagement);
        return $response;
    }


    /**
     * Operation updateConversationEngagementWithHttpInfo
     *
     * Update a engagement
     *
     * @param  int $conversation_engagement_oid (required)
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationEngagementResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConversationEngagementWithHttpInfo($conversation_engagement_oid, $engagement)
    {
        return $this->updateConversationEngagementWithHttpInfoRetry(true ,   $conversation_engagement_oid,   $engagement);
    }


    /**
     * Operation updateConversationEngagementWithHttpInfoRetry
     *
     * Update a engagement
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  int $conversation_engagement_oid (required)
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationEngagementResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConversationEngagementWithHttpInfoRetry($retry ,  $conversation_engagement_oid,  $engagement)
    {
        $returnType = '\ultracart\v2\models\ConversationEngagementResponse';
        $request = $this->updateConversationEngagementRequest($conversation_engagement_oid, $engagement);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updateConversationEngagementWithHttpInfoRetry(false ,   $conversation_engagement_oid,   $engagement);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationEngagementResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateConversationEngagementAsync
     *
     * Update a engagement
     *
     * @param  int $conversation_engagement_oid (required)
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConversationEngagementAsync($conversation_engagement_oid, $engagement)
    {
        return $this->updateConversationEngagementAsyncWithHttpInfo($conversation_engagement_oid, $engagement)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateConversationEngagementAsyncWithHttpInfo
     *
     * Update a engagement
     *
     * @param  int $conversation_engagement_oid (required)
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConversationEngagementAsyncWithHttpInfo($conversation_engagement_oid, $engagement)
    {
        $returnType = '\ultracart\v2\models\ConversationEngagementResponse';
        $request = $this->updateConversationEngagementRequest($conversation_engagement_oid, $engagement);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateConversationEngagement'
     *
     * @param  int $conversation_engagement_oid (required)
     * @param  \ultracart\v2\models\ConversationEngagement $engagement Engagement (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateConversationEngagementRequest($conversation_engagement_oid, $engagement)
    {
        // verify the required parameter 'conversation_engagement_oid' is set
        if ($conversation_engagement_oid === null || (is_array($conversation_engagement_oid) && count($conversation_engagement_oid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_engagement_oid when calling updateConversationEngagement'
            );
        }
        // verify the required parameter 'engagement' is set
        if ($engagement === null || (is_array($engagement) && count($engagement) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $engagement when calling updateConversationEngagement'
            );
        }

        $resourcePath = '/conversation/engagements/{conversation_engagement_oid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_engagement_oid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversation_engagement_oid' . '}',
                ObjectSerializer::toPathValue($conversation_engagement_oid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($engagement)) {
            $_tempBody = $engagement;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateConversationWebchatQueueStatus
     *
     * Update status within the queue
     *
     * @param  string $queue_name queue_name (required)
     * @param  \ultracart\v2\models\ConversationWebchatQueueStatusUpdateRequest $status_request Status request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return void
     */
    public function updateConversationWebchatQueueStatus($queue_name, $status_request)
    {
        $this->updateConversationWebchatQueueStatusWithHttpInfo($queue_name, $status_request);
    }


    /**
     * Operation updateConversationWebchatQueueStatusWithHttpInfo
     *
     * Update status within the queue
     *
     * @param  string $queue_name (required)
     * @param  \ultracart\v2\models\ConversationWebchatQueueStatusUpdateRequest $status_request Status request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConversationWebchatQueueStatusWithHttpInfo($queue_name, $status_request)
    {
        $this->updateConversationWebchatQueueStatusWithHttpInfoRetry(true ,   $queue_name,   $status_request);
    }


    /**
     * Operation updateConversationWebchatQueueStatusWithHttpInfoRetry
     *
     * Update status within the queue
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $queue_name (required)
     * @param  \ultracart\v2\models\ConversationWebchatQueueStatusUpdateRequest $status_request Status request (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of null, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateConversationWebchatQueueStatusWithHttpInfoRetry($retry ,  $queue_name,  $status_request)
    {
        $returnType = '';
        $request = $this->updateConversationWebchatQueueStatusRequest($queue_name, $status_request);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        $this->updateConversationWebchatQueueStatusWithHttpInfoRetry(false ,   $queue_name,   $status_request);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            return [null, $response->getStatusCode(), $response->getHeaders()];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateConversationWebchatQueueStatusAsync
     *
     * Update status within the queue
     *
     * @param  string $queue_name (required)
     * @param  \ultracart\v2\models\ConversationWebchatQueueStatusUpdateRequest $status_request Status request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConversationWebchatQueueStatusAsync($queue_name, $status_request)
    {
        return $this->updateConversationWebchatQueueStatusAsyncWithHttpInfo($queue_name, $status_request)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateConversationWebchatQueueStatusAsyncWithHttpInfo
     *
     * Update status within the queue
     *
     * @param  string $queue_name (required)
     * @param  \ultracart\v2\models\ConversationWebchatQueueStatusUpdateRequest $status_request Status request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateConversationWebchatQueueStatusAsyncWithHttpInfo($queue_name, $status_request)
    {
        $returnType = '';
        $request = $this->updateConversationWebchatQueueStatusRequest($queue_name, $status_request);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    return [null, $response->getStatusCode(), $response->getHeaders()];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateConversationWebchatQueueStatus'
     *
     * @param  string $queue_name (required)
     * @param  \ultracart\v2\models\ConversationWebchatQueueStatusUpdateRequest $status_request Status request (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateConversationWebchatQueueStatusRequest($queue_name, $status_request)
    {
        // verify the required parameter 'queue_name' is set
        if ($queue_name === null || (is_array($queue_name) && count($queue_name) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $queue_name when calling updateConversationWebchatQueueStatus'
            );
        }
        // verify the required parameter 'status_request' is set
        if ($status_request === null || (is_array($status_request) && count($status_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $status_request when calling updateConversationWebchatQueueStatus'
            );
        }

        $resourcePath = '/conversation/conversations/queues/{queue_name}/status';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($queue_name !== null) {
            $resourcePath = str_replace(
                '{' . 'queue_name' . '}',
                ObjectSerializer::toPathValue($queue_name),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($status_request)) {
            $_tempBody = $status_request;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePbxAgent
     *
     * Update pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid conversation_pbx_agent_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAgentResponse
     */
    public function updatePbxAgent($conversation_pbx_agent_uuid, $pbx_agent)
    {
        list($response) = $this->updatePbxAgentWithHttpInfo($conversation_pbx_agent_uuid, $pbx_agent);
        return $response;
    }


    /**
     * Operation updatePbxAgentWithHttpInfo
     *
     * Update pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxAgentWithHttpInfo($conversation_pbx_agent_uuid, $pbx_agent)
    {
        return $this->updatePbxAgentWithHttpInfoRetry(true ,   $conversation_pbx_agent_uuid,   $pbx_agent);
    }


    /**
     * Operation updatePbxAgentWithHttpInfoRetry
     *
     * Update pbx agent
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_agent_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAgentResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxAgentWithHttpInfoRetry($retry ,  $conversation_pbx_agent_uuid,  $pbx_agent)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentResponse';
        $request = $this->updatePbxAgentRequest($conversation_pbx_agent_uuid, $pbx_agent);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updatePbxAgentWithHttpInfoRetry(false ,   $conversation_pbx_agent_uuid,   $pbx_agent);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAgentResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePbxAgentAsync
     *
     * Update pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxAgentAsync($conversation_pbx_agent_uuid, $pbx_agent)
    {
        return $this->updatePbxAgentAsyncWithHttpInfo($conversation_pbx_agent_uuid, $pbx_agent)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePbxAgentAsyncWithHttpInfo
     *
     * Update pbx agent
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxAgentAsyncWithHttpInfo($conversation_pbx_agent_uuid, $pbx_agent)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAgentResponse';
        $request = $this->updatePbxAgentRequest($conversation_pbx_agent_uuid, $pbx_agent);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePbxAgent'
     *
     * @param  string $conversation_pbx_agent_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAgent $pbx_agent Pbx Agent (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePbxAgentRequest($conversation_pbx_agent_uuid, $pbx_agent)
    {
        // verify the required parameter 'conversation_pbx_agent_uuid' is set
        if ($conversation_pbx_agent_uuid === null || (is_array($conversation_pbx_agent_uuid) && count($conversation_pbx_agent_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_agent_uuid when calling updatePbxAgent'
            );
        }
        // verify the required parameter 'pbx_agent' is set
        if ($pbx_agent === null || (is_array($pbx_agent) && count($pbx_agent) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_agent when calling updatePbxAgent'
            );
        }

        $resourcePath = '/conversation/pbx/agent/{conversationPbxAgentUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_agent_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxAgentUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_agent_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($pbx_agent)) {
            $_tempBody = $pbx_agent;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePbxAudio
     *
     * Update pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid conversation_pbx_audio_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxAudioResponse
     */
    public function updatePbxAudio($conversation_pbx_audio_uuid, $pbx_audio)
    {
        list($response) = $this->updatePbxAudioWithHttpInfo($conversation_pbx_audio_uuid, $pbx_audio);
        return $response;
    }


    /**
     * Operation updatePbxAudioWithHttpInfo
     *
     * Update pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudioResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxAudioWithHttpInfo($conversation_pbx_audio_uuid, $pbx_audio)
    {
        return $this->updatePbxAudioWithHttpInfoRetry(true ,   $conversation_pbx_audio_uuid,   $pbx_audio);
    }


    /**
     * Operation updatePbxAudioWithHttpInfoRetry
     *
     * Update pbx audio
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_audio_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxAudioResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxAudioWithHttpInfoRetry($retry ,  $conversation_pbx_audio_uuid,  $pbx_audio)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudioResponse';
        $request = $this->updatePbxAudioRequest($conversation_pbx_audio_uuid, $pbx_audio);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updatePbxAudioWithHttpInfoRetry(false ,   $conversation_pbx_audio_uuid,   $pbx_audio);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxAudioResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePbxAudioAsync
     *
     * Update pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxAudioAsync($conversation_pbx_audio_uuid, $pbx_audio)
    {
        return $this->updatePbxAudioAsyncWithHttpInfo($conversation_pbx_audio_uuid, $pbx_audio)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePbxAudioAsyncWithHttpInfo
     *
     * Update pbx audio
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxAudioAsyncWithHttpInfo($conversation_pbx_audio_uuid, $pbx_audio)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxAudioResponse';
        $request = $this->updatePbxAudioRequest($conversation_pbx_audio_uuid, $pbx_audio);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePbxAudio'
     *
     * @param  string $conversation_pbx_audio_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxAudio $pbx_audio Pbx Audio (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePbxAudioRequest($conversation_pbx_audio_uuid, $pbx_audio)
    {
        // verify the required parameter 'conversation_pbx_audio_uuid' is set
        if ($conversation_pbx_audio_uuid === null || (is_array($conversation_pbx_audio_uuid) && count($conversation_pbx_audio_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_audio_uuid when calling updatePbxAudio'
            );
        }
        // verify the required parameter 'pbx_audio' is set
        if ($pbx_audio === null || (is_array($pbx_audio) && count($pbx_audio) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_audio when calling updatePbxAudio'
            );
        }

        $resourcePath = '/conversation/pbx/audio/{conversationPbxAudioUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_audio_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxAudioUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_audio_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($pbx_audio)) {
            $_tempBody = $pbx_audio;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePbxMenu
     *
     * Update pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid conversation_pbx_menu_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxMenuResponse
     */
    public function updatePbxMenu($conversation_pbx_menu_uuid, $pbx_menu)
    {
        list($response) = $this->updatePbxMenuWithHttpInfo($conversation_pbx_menu_uuid, $pbx_menu);
        return $response;
    }


    /**
     * Operation updatePbxMenuWithHttpInfo
     *
     * Update pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxMenuWithHttpInfo($conversation_pbx_menu_uuid, $pbx_menu)
    {
        return $this->updatePbxMenuWithHttpInfoRetry(true ,   $conversation_pbx_menu_uuid,   $pbx_menu);
    }


    /**
     * Operation updatePbxMenuWithHttpInfoRetry
     *
     * Update pbx menu
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_menu_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxMenuResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxMenuWithHttpInfoRetry($retry ,  $conversation_pbx_menu_uuid,  $pbx_menu)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenuResponse';
        $request = $this->updatePbxMenuRequest($conversation_pbx_menu_uuid, $pbx_menu);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updatePbxMenuWithHttpInfoRetry(false ,   $conversation_pbx_menu_uuid,   $pbx_menu);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxMenuResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePbxMenuAsync
     *
     * Update pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxMenuAsync($conversation_pbx_menu_uuid, $pbx_menu)
    {
        return $this->updatePbxMenuAsyncWithHttpInfo($conversation_pbx_menu_uuid, $pbx_menu)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePbxMenuAsyncWithHttpInfo
     *
     * Update pbx menu
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxMenuAsyncWithHttpInfo($conversation_pbx_menu_uuid, $pbx_menu)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxMenuResponse';
        $request = $this->updatePbxMenuRequest($conversation_pbx_menu_uuid, $pbx_menu);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePbxMenu'
     *
     * @param  string $conversation_pbx_menu_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxMenu $pbx_menu Pbx Menu (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePbxMenuRequest($conversation_pbx_menu_uuid, $pbx_menu)
    {
        // verify the required parameter 'conversation_pbx_menu_uuid' is set
        if ($conversation_pbx_menu_uuid === null || (is_array($conversation_pbx_menu_uuid) && count($conversation_pbx_menu_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_menu_uuid when calling updatePbxMenu'
            );
        }
        // verify the required parameter 'pbx_menu' is set
        if ($pbx_menu === null || (is_array($pbx_menu) && count($pbx_menu) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_menu when calling updatePbxMenu'
            );
        }

        $resourcePath = '/conversation/pbx/menu/{conversationPbxMenuUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_menu_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxMenuUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_menu_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($pbx_menu)) {
            $_tempBody = $pbx_menu;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePbxPhoneNumber
     *
     * Update pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid conversation_pbx_phone_number_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxPhoneNumberResponse
     */
    public function updatePbxPhoneNumber($conversation_pbx_phone_number_uuid, $pbx_phone_number)
    {
        list($response) = $this->updatePbxPhoneNumberWithHttpInfo($conversation_pbx_phone_number_uuid, $pbx_phone_number);
        return $response;
    }


    /**
     * Operation updatePbxPhoneNumberWithHttpInfo
     *
     * Update pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxPhoneNumberWithHttpInfo($conversation_pbx_phone_number_uuid, $pbx_phone_number)
    {
        return $this->updatePbxPhoneNumberWithHttpInfoRetry(true ,   $conversation_pbx_phone_number_uuid,   $pbx_phone_number);
    }


    /**
     * Operation updatePbxPhoneNumberWithHttpInfoRetry
     *
     * Update pbx phoneNumber
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_phone_number_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxPhoneNumberResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxPhoneNumberWithHttpInfoRetry($retry ,  $conversation_pbx_phone_number_uuid,  $pbx_phone_number)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumberResponse';
        $request = $this->updatePbxPhoneNumberRequest($conversation_pbx_phone_number_uuid, $pbx_phone_number);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updatePbxPhoneNumberWithHttpInfoRetry(false ,   $conversation_pbx_phone_number_uuid,   $pbx_phone_number);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxPhoneNumberResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePbxPhoneNumberAsync
     *
     * Update pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxPhoneNumberAsync($conversation_pbx_phone_number_uuid, $pbx_phone_number)
    {
        return $this->updatePbxPhoneNumberAsyncWithHttpInfo($conversation_pbx_phone_number_uuid, $pbx_phone_number)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePbxPhoneNumberAsyncWithHttpInfo
     *
     * Update pbx phoneNumber
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxPhoneNumberAsyncWithHttpInfo($conversation_pbx_phone_number_uuid, $pbx_phone_number)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxPhoneNumberResponse';
        $request = $this->updatePbxPhoneNumberRequest($conversation_pbx_phone_number_uuid, $pbx_phone_number);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePbxPhoneNumber'
     *
     * @param  string $conversation_pbx_phone_number_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxPhoneNumber $pbx_phone_number Pbx PhoneNumber (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePbxPhoneNumberRequest($conversation_pbx_phone_number_uuid, $pbx_phone_number)
    {
        // verify the required parameter 'conversation_pbx_phone_number_uuid' is set
        if ($conversation_pbx_phone_number_uuid === null || (is_array($conversation_pbx_phone_number_uuid) && count($conversation_pbx_phone_number_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_phone_number_uuid when calling updatePbxPhoneNumber'
            );
        }
        // verify the required parameter 'pbx_phone_number' is set
        if ($pbx_phone_number === null || (is_array($pbx_phone_number) && count($pbx_phone_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_phone_number when calling updatePbxPhoneNumber'
            );
        }

        $resourcePath = '/conversation/pbx/phone_number/{conversationPbxPhoneNumberUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_phone_number_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxPhoneNumberUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_phone_number_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($pbx_phone_number)) {
            $_tempBody = $pbx_phone_number;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePbxQueue
     *
     * Update pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid conversation_pbx_queue_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxQueueResponse
     */
    public function updatePbxQueue($conversation_pbx_queue_uuid, $pbx_queue)
    {
        list($response) = $this->updatePbxQueueWithHttpInfo($conversation_pbx_queue_uuid, $pbx_queue);
        return $response;
    }


    /**
     * Operation updatePbxQueueWithHttpInfo
     *
     * Update pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueueResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxQueueWithHttpInfo($conversation_pbx_queue_uuid, $pbx_queue)
    {
        return $this->updatePbxQueueWithHttpInfoRetry(true ,   $conversation_pbx_queue_uuid,   $pbx_queue);
    }


    /**
     * Operation updatePbxQueueWithHttpInfoRetry
     *
     * Update pbx queue
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_queue_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxQueueResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxQueueWithHttpInfoRetry($retry ,  $conversation_pbx_queue_uuid,  $pbx_queue)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueueResponse';
        $request = $this->updatePbxQueueRequest($conversation_pbx_queue_uuid, $pbx_queue);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updatePbxQueueWithHttpInfoRetry(false ,   $conversation_pbx_queue_uuid,   $pbx_queue);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxQueueResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePbxQueueAsync
     *
     * Update pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxQueueAsync($conversation_pbx_queue_uuid, $pbx_queue)
    {
        return $this->updatePbxQueueAsyncWithHttpInfo($conversation_pbx_queue_uuid, $pbx_queue)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePbxQueueAsyncWithHttpInfo
     *
     * Update pbx queue
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxQueueAsyncWithHttpInfo($conversation_pbx_queue_uuid, $pbx_queue)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxQueueResponse';
        $request = $this->updatePbxQueueRequest($conversation_pbx_queue_uuid, $pbx_queue);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePbxQueue'
     *
     * @param  string $conversation_pbx_queue_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxQueue $pbx_queue Pbx Queue (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePbxQueueRequest($conversation_pbx_queue_uuid, $pbx_queue)
    {
        // verify the required parameter 'conversation_pbx_queue_uuid' is set
        if ($conversation_pbx_queue_uuid === null || (is_array($conversation_pbx_queue_uuid) && count($conversation_pbx_queue_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_queue_uuid when calling updatePbxQueue'
            );
        }
        // verify the required parameter 'pbx_queue' is set
        if ($pbx_queue === null || (is_array($pbx_queue) && count($pbx_queue) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_queue when calling updatePbxQueue'
            );
        }

        $resourcePath = '/conversation/pbx/queue/{conversationPbxQueueUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_queue_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxQueueUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_queue_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($pbx_queue)) {
            $_tempBody = $pbx_queue;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePbxTimeBased
     *
     * Update pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid conversation_pbx_time_based_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeBasedResponse
     */
    public function updatePbxTimeBased($conversation_pbx_time_based_uuid, $pbx_time_based)
    {
        list($response) = $this->updatePbxTimeBasedWithHttpInfo($conversation_pbx_time_based_uuid, $pbx_time_based);
        return $response;
    }


    /**
     * Operation updatePbxTimeBasedWithHttpInfo
     *
     * Update pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxTimeBasedWithHttpInfo($conversation_pbx_time_based_uuid, $pbx_time_based)
    {
        return $this->updatePbxTimeBasedWithHttpInfoRetry(true ,   $conversation_pbx_time_based_uuid,   $pbx_time_based);
    }


    /**
     * Operation updatePbxTimeBasedWithHttpInfoRetry
     *
     * Update pbx timeBased
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_time_based_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeBasedResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxTimeBasedWithHttpInfoRetry($retry ,  $conversation_pbx_time_based_uuid,  $pbx_time_based)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedResponse';
        $request = $this->updatePbxTimeBasedRequest($conversation_pbx_time_based_uuid, $pbx_time_based);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updatePbxTimeBasedWithHttpInfoRetry(false ,   $conversation_pbx_time_based_uuid,   $pbx_time_based);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeBasedResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePbxTimeBasedAsync
     *
     * Update pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxTimeBasedAsync($conversation_pbx_time_based_uuid, $pbx_time_based)
    {
        return $this->updatePbxTimeBasedAsyncWithHttpInfo($conversation_pbx_time_based_uuid, $pbx_time_based)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePbxTimeBasedAsyncWithHttpInfo
     *
     * Update pbx timeBased
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxTimeBasedAsyncWithHttpInfo($conversation_pbx_time_based_uuid, $pbx_time_based)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeBasedResponse';
        $request = $this->updatePbxTimeBasedRequest($conversation_pbx_time_based_uuid, $pbx_time_based);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePbxTimeBased'
     *
     * @param  string $conversation_pbx_time_based_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeBased $pbx_time_based Pbx TimeBased (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePbxTimeBasedRequest($conversation_pbx_time_based_uuid, $pbx_time_based)
    {
        // verify the required parameter 'conversation_pbx_time_based_uuid' is set
        if ($conversation_pbx_time_based_uuid === null || (is_array($conversation_pbx_time_based_uuid) && count($conversation_pbx_time_based_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_time_based_uuid when calling updatePbxTimeBased'
            );
        }
        // verify the required parameter 'pbx_time_based' is set
        if ($pbx_time_based === null || (is_array($pbx_time_based) && count($pbx_time_based) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_time_based when calling updatePbxTimeBased'
            );
        }

        $resourcePath = '/conversation/pbx/time_based/{conversationPbxTimeBasedUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_time_based_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxTimeBasedUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_time_based_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($pbx_time_based)) {
            $_tempBody = $pbx_time_based;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePbxTimeRange
     *
     * Update pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid conversation_pbx_time_range_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxTimeRangeResponse
     */
    public function updatePbxTimeRange($conversation_pbx_time_range_uuid, $pbx_time_range)
    {
        list($response) = $this->updatePbxTimeRangeWithHttpInfo($conversation_pbx_time_range_uuid, $pbx_time_range);
        return $response;
    }


    /**
     * Operation updatePbxTimeRangeWithHttpInfo
     *
     * Update pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxTimeRangeWithHttpInfo($conversation_pbx_time_range_uuid, $pbx_time_range)
    {
        return $this->updatePbxTimeRangeWithHttpInfoRetry(true ,   $conversation_pbx_time_range_uuid,   $pbx_time_range);
    }


    /**
     * Operation updatePbxTimeRangeWithHttpInfoRetry
     *
     * Update pbx timeRange
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_time_range_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxTimeRangeResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxTimeRangeWithHttpInfoRetry($retry ,  $conversation_pbx_time_range_uuid,  $pbx_time_range)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangeResponse';
        $request = $this->updatePbxTimeRangeRequest($conversation_pbx_time_range_uuid, $pbx_time_range);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updatePbxTimeRangeWithHttpInfoRetry(false ,   $conversation_pbx_time_range_uuid,   $pbx_time_range);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxTimeRangeResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePbxTimeRangeAsync
     *
     * Update pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxTimeRangeAsync($conversation_pbx_time_range_uuid, $pbx_time_range)
    {
        return $this->updatePbxTimeRangeAsyncWithHttpInfo($conversation_pbx_time_range_uuid, $pbx_time_range)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePbxTimeRangeAsyncWithHttpInfo
     *
     * Update pbx timeRange
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxTimeRangeAsyncWithHttpInfo($conversation_pbx_time_range_uuid, $pbx_time_range)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxTimeRangeResponse';
        $request = $this->updatePbxTimeRangeRequest($conversation_pbx_time_range_uuid, $pbx_time_range);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePbxTimeRange'
     *
     * @param  string $conversation_pbx_time_range_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxTimeRange $pbx_time_range Pbx TimeRange (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePbxTimeRangeRequest($conversation_pbx_time_range_uuid, $pbx_time_range)
    {
        // verify the required parameter 'conversation_pbx_time_range_uuid' is set
        if ($conversation_pbx_time_range_uuid === null || (is_array($conversation_pbx_time_range_uuid) && count($conversation_pbx_time_range_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_time_range_uuid when calling updatePbxTimeRange'
            );
        }
        // verify the required parameter 'pbx_time_range' is set
        if ($pbx_time_range === null || (is_array($pbx_time_range) && count($pbx_time_range) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_time_range when calling updatePbxTimeRange'
            );
        }

        $resourcePath = '/conversation/pbx/time_range/{conversationPbxTimeRangeUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_time_range_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxTimeRangeUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_time_range_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($pbx_time_range)) {
            $_tempBody = $pbx_time_range;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updatePbxVoicemailMailbox
     *
     * Update pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid conversation_pbx_voicemail_mailbox_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse
     */
    public function updatePbxVoicemailMailbox($conversation_pbx_voicemail_mailbox_uuid, $pbx_voicemail_mailbox)
    {
        list($response) = $this->updatePbxVoicemailMailboxWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid, $pbx_voicemail_mailbox);
        return $response;
    }


    /**
     * Operation updatePbxVoicemailMailboxWithHttpInfo
     *
     * Update pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxVoicemailMailboxWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid, $pbx_voicemail_mailbox)
    {
        return $this->updatePbxVoicemailMailboxWithHttpInfoRetry(true ,   $conversation_pbx_voicemail_mailbox_uuid,   $pbx_voicemail_mailbox);
    }


    /**
     * Operation updatePbxVoicemailMailboxWithHttpInfoRetry
     *
     * Update pbx voicemailMailbox
     *
     * @param boolean $retry should this method retry the call if a rate limit is triggered (required)
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \ultracart\v2\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \ultracart\v2\models\ConversationPbxVoicemailMailboxResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePbxVoicemailMailboxWithHttpInfoRetry($retry ,  $conversation_pbx_voicemail_mailbox_uuid,  $pbx_voicemail_mailbox)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse';
        $request = $this->updatePbxVoicemailMailboxRequest($conversation_pbx_voicemail_mailbox_uuid, $pbx_voicemail_mailbox);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {

                if($e->getResponse()) {
                    $response = $e->getResponse();
                    $statusCode = $response->getStatusCode();
                    $retryAfter = 0;
                    $headers = $response->getHeaders();
                    if (array_key_exists('Retry-After', $headers)) {
                        $retryAfter = intval($headers['Retry-After'][0]);
                    }

                    if ($statusCode == 429 && $retry && $retryAfter > 0 && $retryAfter <= $this->config->getMaxRetrySeconds()) {
                        sleep($retryAfter);
                        return $this->updatePbxVoicemailMailboxWithHttpInfoRetry(false ,   $conversation_pbx_voicemail_mailbox_uuid,   $pbx_voicemail_mailbox);
                    }
                }

                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 410:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 429:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\ultracart\v2\models\ErrorResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updatePbxVoicemailMailboxAsync
     *
     * Update pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxVoicemailMailboxAsync($conversation_pbx_voicemail_mailbox_uuid, $pbx_voicemail_mailbox)
    {
        return $this->updatePbxVoicemailMailboxAsyncWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid, $pbx_voicemail_mailbox)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updatePbxVoicemailMailboxAsyncWithHttpInfo
     *
     * Update pbx voicemailMailbox
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updatePbxVoicemailMailboxAsyncWithHttpInfo($conversation_pbx_voicemail_mailbox_uuid, $pbx_voicemail_mailbox)
    {
        $returnType = '\ultracart\v2\models\ConversationPbxVoicemailMailboxResponse';
        $request = $this->updatePbxVoicemailMailboxRequest($conversation_pbx_voicemail_mailbox_uuid, $pbx_voicemail_mailbox);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updatePbxVoicemailMailbox'
     *
     * @param  string $conversation_pbx_voicemail_mailbox_uuid (required)
     * @param  \ultracart\v2\models\ConversationPbxVoicemailMailbox $pbx_voicemail_mailbox Pbx VoicemailMailbox (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updatePbxVoicemailMailboxRequest($conversation_pbx_voicemail_mailbox_uuid, $pbx_voicemail_mailbox)
    {
        // verify the required parameter 'conversation_pbx_voicemail_mailbox_uuid' is set
        if ($conversation_pbx_voicemail_mailbox_uuid === null || (is_array($conversation_pbx_voicemail_mailbox_uuid) && count($conversation_pbx_voicemail_mailbox_uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $conversation_pbx_voicemail_mailbox_uuid when calling updatePbxVoicemailMailbox'
            );
        }
        // verify the required parameter 'pbx_voicemail_mailbox' is set
        if ($pbx_voicemail_mailbox === null || (is_array($pbx_voicemail_mailbox) && count($pbx_voicemail_mailbox) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $pbx_voicemail_mailbox when calling updatePbxVoicemailMailbox'
            );
        }

        $resourcePath = '/conversation/pbx/voicemail_mailbox/{conversationPbxVoicemailMailboxUuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($conversation_pbx_voicemail_mailbox_uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'conversationPbxVoicemailMailboxUuid' . '}',
                ObjectSerializer::toPathValue($conversation_pbx_voicemail_mailbox_uuid),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($pbx_voicemail_mailbox)) {
            $_tempBody = $pbx_voicemail_mailbox;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['application/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['application/json'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }
        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('x-ultracart-simple-key');
        if ($apiKey !== null) {
            $headers['x-ultracart-simple-key'] = $apiKey;
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
